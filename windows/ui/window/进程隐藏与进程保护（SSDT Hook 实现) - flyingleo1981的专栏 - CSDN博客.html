
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    
    <html xmlns="http://www.w3.org/1999/xhtml">
    
<head>  
            <link rel="canonical" href="http://blog.csdn.net/flyingleo1981/article/details/47276173"/> 

   

  
 <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />

    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848"> 
       
    <title>进程隐藏与进程保护（SSDT Hook 实现) - flyingleo1981的专栏
        - CSDN博客</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="description" content="进程隐藏与进程保护（SSDT Hook 实现）（一）文章目录：&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 1. 引子 – Hook 技术：2. SSDT 简介：3. 应用层调用 Win32 API 的完整执行流程：4. 详解 SSDT：5. SSDT&#160; Hook 原理：6. 小结：&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 1. 引子 – Hook 技术：&#160;&#160;&#160;&#160;&#160; " />

    <meta name="keywords" content="" />

   
    <script src="http://static.blog.csdn.net/scripts/blog_static_head.min.js" type="text/javascript"></script>

    
        <!--new top-->
       
       
        <!--new top-->
    
      <!-- ad begin -->
         
    <!-- ad end-->

    <link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/default/css/style.css?v=1.1" />

    

    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/flyingleo1981/rss/list" />
    <link rel="shortcut icon" href="http://c.csdnimg.cn/public/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/default.css" />
 



    <link href="http://c.csdnimg.cn/blog/csdn_public_blog_detail.min.css" type="text/css" rel="stylesheet" />
     
         <link rel="stylesheet" href="http://static.blog.csdn.net/css/csdn_blog_detail.min.css" />

  


    <!-- 请置于所有广告位代码之前 --> 
            <script src="http://dup.baidustatic.com/js/ds.js"></script>

</head>


<body>
     
        <div class="tracking-ad" data-view="true" data-mod="ad_popu_72"  data-mtp="62" data-order="40" data-con="ad_content_2072" >
                     <script id="popuLayer_js_q" src="http://ads.csdn.net/js/popuLayer.js" defer="defer"  type="text/javascript"></script>
                <div id="layerd" style="position: fixed;bottom:0px;right:0px;line-height:0px;z-index:1000">
    	                <div class="J_close layer_close" style="display:;background-color:#efefef;padding:0px;color:#333;font:12px/24px Helvetica,Tahoma,Arial,sans-serif;text-align:right;">关闭</div><!-- 广告占位容器 --><div id="cpro_u2895327"></div></div>
                <script>  document.getElementById("popuLayer_js_q").onload = function () { var styObjd = styObj = { width: "300px", "height": parseInt(250) + 28 }; window.CSDN.Layer.PopuLayer("#layerd", { storageName: "layerd", styleObj: styObjd, total: 50, expoire: 1000 * 60 }); }</script><!-- 投放代码 --><script type="text/javascript">                    /*服务器频道首页置顶Banner960*90，创建于2014-7-3*/    (window.cproArray = window.cproArray || []).push({ id: "u2895327" });  </script>  <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
     
        </div>

    <!-- 广告位开始 -->
        
    <!-- 广告位结束 -->

    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="http://c.csdnimg.cn/public/common/toolbar/js/html.js" type="text/javascript"></script>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/flyingleo1981">flyingleo1981的专栏</a></h2>
            <h3></h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
        
     
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>           
                <li id="btnContents"><a href="http://blog.csdn.net/flyingleo1981?viewmode=contents"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])">
                    <img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/flyingleo1981?viewmode=list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])">
                    <img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/flyingleo1981/rss/list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])">
                    <img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>                
            

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "flyingleo1981";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/flyingleo1981";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";  
</script>

        <div id="body">
            <div id="main">
                <div class="main">
                        <div class="ad_class">
<div class="notice tracking-ad" data-mod='popu_3' > 


<a href="http://blog.csdn.net/epubit17/article/details/77770966">
<font color=red><strong>异步赠书：Kotlin领衔10本好书</strong></font></a>

&nbsp;&nbsp;&nbsp;&nbsp

<a href="http://edu.csdn.net/huiyiCourse/series_detail/63">
<font color=red><strong>免费直播：AI时代，机器学习如何入门？</strong></font></a>

&nbsp;&nbsp;&nbsp;&nbsp

<a href="http://blog.csdn.net/turingbooks/article/details/77479427">
<font color=blue><strong>程序员8月书讯</strong></font></a>

&nbsp;&nbsp;&nbsp;&nbsp


<a href="https://gitee.com/enterprises?from=csdn-sqbkxq">
<font color=red><strong>项目管理+代码托管+文档协作，开发更流畅</strong></font></a>



</div>                        </div>

                        



  






<script   type="text/javascript" src="http://static.blog.csdn.net/scripts/category.js"></script>

  <script type="text/ecmascript">
      window.quickReplyflag = true;
      var isBole = false; 
      var fasrc="http://my.csdn.net/my/favorite/miniadd?t=%e8%bf%9b%e7%a8%8b%e9%9a%90%e8%97%8f%e4%b8%8e%e8%bf%9b%e7%a8%8b%e4%bf%9d%e6%8a%a4%ef%bc%88SSDT+Hook+%e5%ae%9e%e7%8e%b0)&u=http://blog.csdn.net/flyingleo1981/article/details/47276173"
    </script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Repost"></span>

    <h1>
        <span class="link_title"><a href="/flyingleo1981/article/details/47276173">
        进程隐藏与进程保护（SSDT Hook 实现)        
           
        </a>
        </span>

         
    </h1>
</div>

   

        <div class="article_manage clearfix">
        <div class="article_r">
            <span class="link_postdate">2015-08-04 14:20</span>
            <span class="link_view" title="阅读次数">2026人阅读</span>
            <span class="link_comments" title="评论次数"> <a href="#comments" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])">评论</a>(1)</span>
            <span class="link_collect tracking-ad" data-mod="popu_171"> <a href="javascript:void(0);" onclick="javascript:collectArticle('%e8%bf%9b%e7%a8%8b%e9%9a%90%e8%97%8f%e4%b8%8e%e8%bf%9b%e7%a8%8b%e4%bf%9d%e6%8a%a4%ef%bc%88SSDT+Hook+%e5%ae%9e%e7%8e%b0)','47276173');return false;" title="收藏">收藏</a></span>
             <span class="link_report"> <a href="#report" onclick="javascript:report(47276173,2);return false;" title="举报">举报</a></span>

        </div>
    </div>    <style type="text/css">        
            .embody{
                padding:10px 10px 10px;
                margin:0 -20px;
                border-bottom:solid 1px #ededed;                
            }
            .embody_b{
                margin:0 ;
                padding:10px 0;
            }
            .embody .embody_t,.embody .embody_c{
                display: inline-block;
                margin-right:10px;
            }
            .embody_t{
                font-size: 12px;
                color:#999;
            }
            .embody_c{
                font-size: 12px;
            }
            .embody_c img,.embody_c em{
                display: inline-block;
                vertical-align: middle;               
            }
             .embody_c img{               
                width:30px;
                height:30px;
            }
            .embody_c em{
                margin: 0 20px 0 10px;
                color:#333;
                font-style: normal;
            }
    </style>
    <script  type="text/javascript">
        $(function () {
            try
            {
                var lib = eval("("+$("#lib").attr("value")+")");
                var html = "";
                if (lib.err == 0) {
                    $.each(lib.data, function (i) {
                        var obj = lib.data[i];
                        //html += '<img src="' + obj.logo + '"/>' + obj.name + "&nbsp;&nbsp;";
                        html += ' <a href="' + obj.url + '" target="_blank">';
                        html += ' <img src="' + obj.logo + '">';
                        html += ' <em><b>' + obj.name + '</b></em>';
                        html += ' </a>';
                    });
                    if (html != "") {
                        setTimeout(function () {
                            $("#lib").html(html);                      
                            $("#embody").show();
                        }, 100);
                    }
                }      
            } catch (err)
            { }
            
        });
    </script>

  

  
  
     


<div id="article_content" class="article_content tracking-ad" data-mod=popu_307  data-dsm = "post" >

<h1 class="postTitle"><a target="_blank" id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html">进程隐藏与进程保护（SSDT Hook 实现）（一）</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div id="cnblogs_post_body">
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>文章目录：</strong></span></p>
<p><span style="font-family:微软雅黑"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>1. 引子 – Hook 技术：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>2. SSDT 简介：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>3. 应用层调用 Win32 API 的完整执行流程：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>4. 详解 SSDT：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>5. SSDT&nbsp; Hook 原理：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>6. 小结：</strong></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>1. 引子 – Hook 技术：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">前面一篇博文呢介绍了代码的注入技术(远程线程实现)，博文地址如下：</span></p>
<p><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/08/11/2134367.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/08/11/2134367.html</span></a></p>
<p><span style="font-family:Courier New; font-size:12px">虽然代码注入是很老的技术了，但是这种技术也还是比较常见，</span></p>
<p><span style="font-family:Courier New; font-size:12px">当然也比较好用的，</span><span style="font-family:Courier New; font-size:12px">比如在 Spy&#43;&#43; 中就使用了远程线程注入技术，</span></p>
<p><span style="font-family:Courier New; font-size:12px">同时，如果有兴趣的阅读过 Spy&#43;&#43; 的源码的朋友，</span><span style="font-family:Courier New; font-size:12px">当然也可以在其源码中阅读到关于远程线程注入技术了。</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">（这篇博文虽然我会截断分为两篇博文撰写，但是博文仍然会比较长，内容其实是比较多的，覆盖面也比较广，</span></p>
<p><span style="font-family:Courier New; font-size:12px">需要有一定耐心和基础方可阅读完，</span><span style="font-family:Courier New; font-size:12px">有兴趣者请自备茶水以及零食，然后慢慢阅读全文，</span></p>
<p><span style="font-family:Courier New; font-size:12px">PS：这话引用自园子里某位园友）</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">（<span style="font-family:Courier New; font-size:12px">然后的话就是漫漫长夜，心情不佳，于是写了篇博文，刚好又喝了点，所以估计会有些许疏漏之处，还请见谅 ~</span>）</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">在这一篇博文中呢，介绍的是一种 Hook 技术，对于 Hook 技术，可以分为两块，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第一块是在 Ring3 层的 Hook，俗称应用层 Hook 技术，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而另外一块自然是在 Ring0 层得 Hook，</span><span style="font-family:Courier New; font-size:12px">俗称为内核层 Hook 技术，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而在 Ring3 层的 Hook 基本上可以分为两种大的类型，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第一类即是 Windows 消息的 Hook，第二类则是 Windows API 的 Hook。</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>关于 Hook 的几种类型呢，下面给出几个简洁的图示：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815403696.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815428321.png" width="606" height="275" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/20110903081543895.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815446567.png" width="620" height="245" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815459698.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/20110903081547768.png" width="806" height="423" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">关于 Windows 消息的 Hook，相信很多朋友都有接触过的，因为一个 SetWindowsHookEx 即可以完成消息 Hook，</span></p>
<p><span style="font-family:Courier New; font-size:12px">在这里简要介绍一下消息 Hook，消息 Hook 是通过 SetWindowsHookEx 可以实现将自己的钩子插入到钩子链的最前端，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而对于发送给被 Hook 的窗口(也有可能是所有的窗口，即全局 Hook)的消息都会被我们的钩子处理函数所捕获到，</span></p>
<p><span style="font-family:Courier New; font-size:12px">也就是我们可以优先于窗体先捕获到这些消息，Windows 消息 Hook 可以实现为进程内消息 Hook 和全局消息 Hook，</span></p>
<p><span style="font-family:Courier New; font-size:12px">对于进程内消息 Hook，则可以简单的将 Hook 处理函数直接写在这个进程内，即是自己 Hook 自己，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而对于用途更为广泛的全局消息 Hook，则需要将 Hook 处理函数写在一个 DLL 中，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这样才可以让你的处理函数被所有的进程所加载(进程自动加载包含 Hook 消息处理函数的 DLL)。</span></p>
<p><span style="font-family:Courier New; font-size:12px">对于 Windows 消息 Hook 呢，可以有个简单的邪恶应用，就是记录键盘按键消息，</span></p>
<p><span style="font-family:Courier New; font-size:12px">从而达到监视用户输入的键&#20540;信息的目的，</span><span style="font-family:Courier New; font-size:12px">这样，对于一些简单的用户通过键盘输入的密码就可以被 Hook 获取到，</span></p>
<p><span style="font-family:Courier New; font-size:12px">因为没当用户按下一个键时，Windows 都会产生一个按键消息(当然有按下，弹起等消息的区分)，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后我们可以 Hook 到这个按键消息，这样就可以在 Hook 的消息处理函数中获取到用户按下的是什么键了。</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">当然关于消息 Hook 的话，其不是这篇博文的重点，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>这篇博文主要介绍的是 SSDT Hook 技术，即内核 Hook 技术的一种，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">这种技术呢，也是比较老的技术了，貌&#20284;是当年 Rootkit 起火的时候出来的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">但是 SSDT Hook 现在也还比较流行，比如在很多的杀毒软件或者安全软件里面也都会使用到 SSDT Hook 技术。</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>关于内核 Hook 也有几种类型，下面也给出一副图示：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815479995.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815507718.png" width="705" height="574" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">上面的几种内核级 Hook 技术，在看雪啊，debugman，xfocus 上都有很多的介绍，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而我只不过是落后这些技术很多年的小辈后生，在这里也只是将自己的学习以及一些总结的经验给列出来而已，</span></p>
<p><span style="font-family:Courier New; font-size:12px">如果有兴趣想深入了解这些内容的话，完全可以在看雪上找到资料 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>2. SSDT 简介：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>以下介绍来自百度(PS:被百度文库弄去了很多博文，这里也抄它一下)：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><u>SSDT 的全称是 System Services Descriptor Table，系统服务描述符表。</u></span></p>
<p><span style="font-family:Courier New; font-size:12px"><u>这个表就是一个把 Ring3 的 Win32 API 和 Ring0 的内核 API 联系起来。</u></span></p>
<p><span style="font-family:Courier New; font-size:12px"><u>SSDT 并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等。</u></span></p>
<p><span style="font-family:Courier New; font-size:12px"><u>通过修改此表的函数地址可以对常用 Windows 函数及 API 进行 Hook，从而实现对一些关心的系统动作进行过滤、监控的目的。</u></span></p>
<p><span style="font-family:Courier New; font-size:12px"><u>一些 HIPS、防毒软件、系统监控、注册表监控软件往往会采用此接口来实现自己的监控模块。</u></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">在 NT 4.0 以上的 Windows 操作系统中，默认就存在两个系统服务描述表，这两个调度表对应了两类不同的系统服务，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这两个调度表为：KeServiceDescriptorTable 和 KeServiceDescriptorTableShadow，</span></p>
<p><span style="font-family:Courier New; font-size:12px">其中 KeServiceDescriptorTable 主要是处理来自 Ring3 层得 Kernel32.dll 中的系统调用，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而 KeServiceDescriptorTableShadow 则主要处理来自 User32.dll 和 GDI32.dll 中的系统调用，</span></p>
<p><span style="font-family:Courier New; font-size:12px">并且 KeServiceDescriptorTable 在 ntoskrnl.exe(Windows 操作系统内核文件，包括内核和执行体层)是导出的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而 KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而关于 SSDT 的全部内容则都是通过 KeServiceDescriptorTable 来完成的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>从下面的截图可以看出 KeServiceDescriptorTable 在 ntoskrnl.exe 中被导出：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815513215.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815564823.png" width="841" height="475" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>然后我们再来看看在 Windows 操作系统的源码 WRK 中，KeServiceDescriptorTable 是怎么被定义的 ~</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">首先来看 KeServiceDescriptorTable 是如何被 Windows 操作系统源码给导出的：</span></p>
<p><span style="font-family:Courier New; font-size:12px">从下面的截图可以看出，这个系统服务描述表是在 WRK 源码中的某一个模块划分文件(.def)中所导出的。</span></p>
<p><span style="font-family:Courier New; font-size:12px">关于 WRK 是什么东西 ? 则可以参阅我的另一篇博文<strong>《Windows 内核(WRK)简介》</strong>，博文地址如下：</span></p>
<p><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/01/08/1930904.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/01/08/1930904.html</span></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030815577431.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816007761.png" width="762" height="301" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><strong><span style="font-family:Courier New; font-size:12px">而在 Windows 源码 WRK 中对于系统服务描述符表的代码定义如下</span><span style="font-family:Courier New; font-size:12px">(KeServiceDecriptorTable 即由该结构定义)：</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816011240.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816055781.png" width="815" height="372" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">上面的这个结构定义在成员变量的名称上还看不出什么名堂，下面给出我们将在自己代码中所使用的结构体：</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>typedef <span class="kwrd">struct</span> _KSYSTEM_SERVICE_TABLE</pre>
<pre><span class="lnum">   2:  </span>{</pre>
<pre class="alt"><span class="lnum">   3:  </span>    PULONG  ServiceTableBase;          <span class="rem">// SSDT (System Service Dispatch Table)的基地址</span></pre>
<pre><span class="lnum">   4:  </span>    PULONG  ServiceCounterTableBase;   <span class="rem">// 用于 checked builds, 包含 SSDT 中每个服务被调用的次数</span></pre>
<pre class="alt"><span class="lnum">   5:  </span>    ULONG   NumberOfService;           <span class="rem">// 服务函数的个数, NumberOfService * 4 就是整个地址表的大小</span></pre>
<pre><span class="lnum">   6:  </span>    ULONG   ParamTableBase;            <span class="rem">// SSPT(System Service Parameter Table)的基地址</span></pre>
<pre class="alt"><span class="lnum">   7:  </span>&nbsp;</pre>
<pre><span class="lnum">   8:  </span>} KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</pre>
<pre class="alt"><span class="lnum">   9:  </span>&nbsp;</pre>
<pre><span class="lnum">  10:  </span>typedef <span class="kwrd">struct</span> _KSERVICE_TABLE_DESCRIPTOR</pre>
<pre class="alt"><span class="lnum">  11:  </span>{</pre>
<pre><span class="lnum">  12:  </span>    KSYSTEM_SERVICE_TABLE   ntoskrnl;  <span class="rem">// ntoskrnl.exe 的服务函数</span></pre>
<pre class="alt"><span class="lnum">  13:  </span>    KSYSTEM_SERVICE_TABLE   win32k;    <span class="rem">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)</span></pre>
<pre><span class="lnum">  14:  </span>    KSYSTEM_SERVICE_TABLE   notUsed1;</pre>
<pre class="alt"><span class="lnum">  15:  </span>    KSYSTEM_SERVICE_TABLE   notUsed2;</pre>
<pre><span class="lnum">  16:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  17:  </span>} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</pre>
<pre><span class="lnum">  18:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  19:  </span><span class="rem">//导出由 ntoskrnl.exe 所导出的 SSDT</span></pre>
<pre><span class="lnum">  20:  </span><span class="kwrd">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>有了上面的介绍后，我们可以简单的将 KeServiceDescriptor 看做是一个数组了(其实质也就是个数组)，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在应用层 ntdll.dll 中的 API 在这个系统服务描述表(SSDT)中都存在一个与之相对应的服务，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>当我们的应用程序调用 ntdll.dll 中的 API 时，最终会调用内核中与之相对应的系统服务，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>由于有了 SSDT，所以我们只需要告诉内核需要调用的服务所在 SSDT 中的索引就 OK 了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后内核根据这个索引&#20540;就可以在 SSDT 中找到相对应的服务了，然后再由内核调用服务完成应用程序 API 的调用请求即可。</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>基本结构可以参考下图：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816069751.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816078454.png" width="709" height="168" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>3. 应用层调用 Win32 API 的完整执行流程：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">有了上面的 SSDT 基础后，我们再来看一下在应用层调用 Win32 API(这里主要指的是 ntdll.dll 中的 API)的完整流程，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这里我们主要是分析 ntdll.dll 中的 NtQuerySystemInformation 这个 API 的调用流程，</span></p>
<p><span style="font-family:Courier New; font-size:12px">(PS:Windows 任务管理器即是通过这个 API 来获取到系统的进程等等信息的)。</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>先给出一副图示(先记住这里有四个类&#20284;的 API，但是必须得注意区分开来，弄混淆了就麻烦大了)：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816089110.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816113867.png" width="835" height="416" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>再给出这些个 API 的基本的调用流程(让大伙有个印象，至少不会迷失)：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816128983.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816151232.png" width="703" height="415" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:Courier New; font-size:12px"></span></p>
<p><span style="font-family:Courier New; font-size:12px">首先，使用 PE 工具来打开 ntdll.dll 文件，可以看到 NtQuerySystemInformation，</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816152411.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816189120.png" width="845" height="295" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">除了 NtQuerySystemInformation 外，同时还可以看到 ZwQuerySystemInformation，</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816194235.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816233203.png" width="837" height="326" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">而实质上，在 Windows 操作系统中，</span></p>
<p><span style="font-family:Courier New; font-size:12px">Ntdll.dll 中的ZwQuerySystemInformation 和 NtQuerySystemInformation 是同一函数，</span></p>
<p><span style="font-family:Courier New; font-size:12px">可以通过下面的截图看出，这两个函数的入口地址指向同一区域，</span><span style="font-family:Courier New; font-size:12px">他们的函数入口地址都是一样的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">很奇怪吧 ~ 其实我也觉得奇怪 ~ 何必多此一举呢 ~
</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816248286.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816256814.png" width="876" height="182" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>众所周知 Ntdll.dll 中的 API 都只不过是一个简单的包装函数而已，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>当 Kernel32.dll 中的 API 通过 Ntdll.dll 时，会完成参数的检查，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>再调用一个中断(int 2Eh 或者 SysEnter 指令)，</strong></span><span style="color:#0000ff"><strong><span style="font-family:Courier New; font-size:12px">从而实现从</span><span style="font-family:Courier New; font-size:12px">
 Ring3 进入 Ring0 层，</span></strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>并且将所要调用的服务号(也就是在 SSDT 数组中的索引&#20540;)存放到寄存器 EAX 中，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>并且将参数地址放到指定的寄存器(EDX)中，再将参数复制到内核地址空间中，</strong></span></p>
<p><span style="color:#0000ff"><strong><span style="font-family:Courier New; font-size:12px">再根据存放在 EAX 中的索引&#20540;来在 SSDT 数组中调用指定的服务 ~
</span></strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:18px; color:#000000"><strong>经过上面的步骤后，便由 Ring3 层进入了 Ring0 层，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">我们再通过 PE 工具来查看 ntoskrnl.exe 中的 ZwQuerySystemInformation 和 NtQuerySystemInformation</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816271407.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816303373.png" width="788" height="321" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816317409.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816344151.png" width="758" height="315" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>先来看 ntoskrnl.exe 中的 ZwQuerySystemInformation：</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816358361.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816378036.png" width="747" height="301" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在上面的这幅截图中，可以看到在 Ring0 下的 ZwQuerySystemInformation 将 0ADh 放入了寄存器 eax 中，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后调用了系统服务分发函数 KiSystemService，而这个 KiSystemService 函数则是根据 eax 寄存器中的索引&#20540;，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后再 SSDT 数组中找到索引&#20540;为 eax 寄存器中存放的&#20540;得那个 SSDT 项，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>最后就是根据这个 SSDT 项中所存放的系统服务的地址来调用这个系统服务了 ~
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">比如在这里就是调用 KeServiceDescriptorTable[0ADh] 处所保存的地址所对应的系统服务了 ~
</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">也就是调用 Ring0 下的 NtQuerySystemInformation 了 ~
</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">至此，在应用层中调用 NtQuerySystemInformation 的全部流程也就结束了 ~
</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">最后，贴出一点在 Ring0 下的 NtQuerySystemInformation 的反汇编代码：</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816378102.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816394397.png" width="808" height="262" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>4. 详解 SSDT：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">在这一节里面，我们将来看看 SSDT 到底是个什么东西 ~
</span><span style="font-family:Courier New; font-size:12px">这里使用 WinDbg 来调试 XP SP2 系统 ~</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>首先来看看 KeServiceDescriptorTable 是何物 ?</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px">从下面的截图中可以看到 KeServiceDesciptorTable 的首地址为 804e58a0，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">然后查看分析这个地址，可以查看到第一个系统服务的入口地址为 80591bfb ！</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px"><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816405368.gif"><img title="2011-08-18_012703" border="0" alt="2011-08-18_012703" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816424137.gif" width="489" height="483" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>我们再来看看 80591bfb 这个地址对应的究竟是何系统服务 ?</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px">从下面的截图中，可以看到 SSDT 中第一个系统服务就是 NtAcceptConnectPort !!!</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px"><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816435665.gif"><img title="2011-08-18_013027" border="0" alt="2011-08-18_013027" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816451403.gif" width="734" height="518" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></span></strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:Courier New; font-size:12px"><strong>由于我们知道了 SSDT 的首地址，又知道了 Ring0 下 NtQuerySystemInformation 服务的索引号，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>所以可以根据 <span style="color:#0000ff">
“SSDT 中系统服务地址所在的 Address = SSDT 首地址 &#43; 4 * 索引号”,</span></strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>推算出 NtQuerySystemInformation 服务的地址，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>因此有 Address = 804e58a0 &#43; 4 * 0adh = 804E5B54；</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>然后我们再来看 804E5B54 这个地址的信息，信息如下截图：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>从截图中，我们可以看到 NtQuerySystemInformation 的起始地址为 80586ff1，</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816468961.gif"><img title="2011-08-18_020103" border="0" alt="2011-08-18_020103" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816477980.gif" width="579" height="251" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>&nbsp; </strong></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>下面就来验证一下地址 80586ff1 到底是不是 NtQuerySystemInformation 的首地址 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>从下面的截图中可以肯定 80586ff1 确实就是 NtQuerySystemInformation 的首地址，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>这和我们上面对 SSDT 中指定索引号的服务的地址的计算公式计算出来的结果是统一的 !!!</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816471634.gif"><img title="2011-08-18_020231" border="0" alt="2011-08-18_020231" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816489781.gif" width="771" height="247" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>从上面的介绍，可以看出，其实 SSDT 就是一个用来保存 Windows 系统服务地址的数组而已 !!!</strong></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>5. SSDT&nbsp; Hook 原理：</strong></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>有了上面的这部分基础后，就可以来看 SSDT HOOK 的原理了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>其实 SSDT Hook 的原理是很简单的，从上面的分析中，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>我们可以知道在 SSDT 这个数组中呢，保存了系统服务的地址，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>比如对于 Ring0 下的 NtQuerySystemInformation 这个系统服务的地址，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>就保存在 KeServiceDescriptorTable[0ADh] 中，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>既然是 Hook 的话，我们就可以将这个 KeServiceDescriptorTable[0ADh] 下保存的服务地址替换掉，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>将我们自己的 Hook 处理函数的地址来替换掉原来的地址，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>这样当每次调用 KeServiceDescriptorTable[0ADh]时就会调用我们自己的这个 Hook 处理函数了。</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>下面用几幅截图来表示：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816494340.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816522653.png" width="828" height="378" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>下面的截图则是 SSDT Hook 之后了，可以看到将 SSDT 中的服务地址修改为 MyHookNtQuerySystemInformation 了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>这样的话，每次系统调用 NtQuerySystemInformation 这个系统服务时，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>实质上调用的就是 MyHookNtQuerySystemInformation 了，而我们为了保证系统的稳定性(至少不让其崩溃)，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>一般会在 MyHookNtQuerySystemInformation 中调用系统中原来的服务，也就是 NtQuerySystemInformation。</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816538640.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109030816565623.png" width="865" height="532" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>6. 小结：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">本篇博文呢尚还只是介绍了 SSDT 到底是个什么东西，而还没有给出具体的 SSDT Hook 的实现，</span></p>
<p><span style="font-family:Courier New; font-size:12px">对于 SSDT Hook 的实现以及 Demo 我都放到(二)中完成，也就是本篇博文未完 , 待续 ……</span></p>
<p><span style="font-family:Courier New; font-size:12px">关于 SSDT 的话，在看雪上有很多的文章，由于我也是前阵子对这东西突然感兴趣了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以我也算是初次了解，自然也看过了很多的文章，SSDT 在 Google 一搜索可以出来一大堆，</span></p>
<p><span style="font-family:Courier New; font-size:12px">但是要说介绍 SSDT 最详细的话，我想还是我的这篇文章介绍的比较详细，</span></p>
<p><span style="font-family:Courier New; font-size:12px">因为网上很多介绍 SSDT 的都只是将 SSDT 原理做了简单的介绍，然后在网上 down 一个 Demo，</span></p>
<p><span style="font-family:Courier New; font-size:12px">把代码贴出来就完事了，</span><span style="font-family:Courier New; font-size:12px">甚至是代码都还无法完整编译通过的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以如果读者想对 SSDT 有所了解的话，可以好好看一看这篇文章的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>顺便这里还带出一个问题，是我这阵子脑子里突然冒出来的一个疑问，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>但是由于时间或者说是个人状态问题，一直没有去研究 ~ 不晓得园子里有木有对这个有研究的 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>众所周知，在 Windows 操作系统中，System 进程的进程 PID 为 4，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>我想问的就是：System 进程的 PID 为何是 4 ?
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">欢迎大家对这个问题讨论啊 ~
</span></strong><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在这里先给点思路，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>那就是可以通过 Windows 操作系统的启动过程，然后结合 WRK 源码进行研究 ~&nbsp;</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong><br>
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><span style="font-weight:bold"></span></span></p>
<h1 class="postTitle"><a target="_blank" id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/04/2166596.html">进程隐藏与进程保护（SSDT Hook 实现）（二）</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div id="cnblogs_post_body">
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>文章目录：</strong></span></p>
<p><span style="font-family:微软雅黑"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>1. 引子 – Demo 实现效果：</strong></span></p>
<p><strong><span style="font-family:微软雅黑; font-size:12px; color:#0000ff">2. 进程隐藏与进程保护概念：</span></strong></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>3. SSDT Hook 框架搭建：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>4. Ring0 实现进程隐藏：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>5. Ring0 实现进程保护：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>6. 隐藏进程列表和保护进程列表的维护：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>7. 小结：</strong></span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>1. 引子 – Demo 实现效果：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p><span style="font-family:Courier New; font-size:12px">上一篇《进程隐藏与进程保护(SSDT Hook 实现)(一)》呢把 SSDT 说得差不多了，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>博文地址：</strong></span></p>
<p><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html</span></a></p>
<p><span style="font-family:Courier New; font-size:12px">不过呢，那也只是些理论的东西，看不到什么实物，估计说来说去把人说晕了后，也没什么感觉，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而这一篇博文的话，给出点新意的，让人头脑清醒点的 ~ 所以先给个 Demo 出来吧 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">(不好意思，本着不喝倒怎出得了好文章这个理由，所以今天又喝多了点，文章有疏忽之处还请见谅 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">顺便在这里跟朋友们分享一下哈，晚上于这个时间点，比如 2 点的时候啊，喝点小酒，</span></p>
<p><span style="font-family:Courier New; font-size:12px">听点曲子，你会精神振奋，头脑更加清醒，思路也会很清晰，尤其是写起程序来那是唰唰的来の ~ )</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>进程隐藏效果：</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px">应用程序主界面：</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041808024709.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041808142376.png" width="732" height="492" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><strong><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">隐藏进程 taskmgr.exe：</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041808242626.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041808438021.png" width="976" height="656" style="border-right-width:0px; padding-left:0px; width:952px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><strong><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">取消进程隐藏 taskmgr.exe：</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041808549143.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809133109.png" width="936" height="633" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><strong><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">进程保护效果：</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>进程保护(保护自身进程 SSDTProcess.exe)：</strong></span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809207424.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809348735.png" width="903" height="529" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><strong><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">取消进程保护(这里还是以 SSDTProcess.exe 为例)：</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">下面的截图表示 SSDTProcess.exe 已经被取消了保护，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px">此时再到任务管理器中结束 SSDTProcess.exe 时，</span><span style="font-family:Courier New; font-size:12px">你可以发现是可以正常结束这个进程的 ~
</span></strong></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809403441.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809535733.png" width="694" height="527" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>2. 进程隐藏与进程保护概念：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p><span style="font-family:Courier New; font-size:12px">在 Ring3 下获取到当前 Windows 操作系统下的所有的进程无外乎以下的几种方法：</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>第一种：</strong>使用 ToolHelp 遍历获取到所有进程，关于这种方式的话，笔者以前写过一篇博文的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">《列举 Windows 所有进程(ToolHelp)》博文地址如下：</span></p>
<p><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/02/27/1966383.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/02/27/1966383.html</span></a></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>第二种：</strong>使用 PSAPI 下的 EnumProcesses 获取到所有进程的 PID，然后提升进程权限为 SE_DEBUG 权限，</span></p>
<p><span style="font-family:Courier New; font-size:12px">再调用 OpenProcess 即可打开进程，从而获取到进程的基本信息(可以查看 MSDN 的 PSAPI 专题)。</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>第三种：</strong>使用未公开的本地 API 即位于 Ntdll.dll 中的未文档化的 API – NtQuerySystemInformation，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而 Windows 任务管理器就是通过这种方式来获取到所有的进程信息的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">而事实上的是，ToolHelp 和 PSAPI 只不过是对 Ntdll.dll 中 NtQuerySystemInformation API 的一个封装，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以在 Ring3 下获取系统中所有进程信息最终都会回到 Ndll.dll 中 NtQuerySystemInformation API 的调用上。</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>如果要实现在 Ring3 中对进程进行隐藏的话，只需要 Hook 掉 NtQuerySystemInformation API 即可。</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">而至于进程保护的话，我们需要考虑到两种情况，第一种则是该进程自行终止，第二种情况则是该进程被其他进程给杀掉，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第一种情况基本上对于窗口应用程序来说，一般都是用户点击了右上角的 x 按钮，然后产生 WM_CLOSE 消息，</span></p>
<p><span style="font-family:Courier New; font-size:12px">最后由窗口过程退出进程，这种情况下，我们应该是需要允许退出的，也就是进程是可以正常退出的。</span></p>
<p><span style="font-family:Courier New; font-size:12px">而第二种情况的话，就是进程被别的进程杀掉，比如在任务管理器中就可以杀掉绝大部分的应用程序进程，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而这里的进程保护就是要实现进程不能够被任务管理器或者其他的进程管理工具杀掉。</span></p>
<p><span style="font-family:Courier New; font-size:12px">在 Ring3 中，由一个进程结束其他进程，调用的 API 为 Kernel32.dll 中的 TerminateProcess，</span></p>
<p><span style="font-family:Courier New; font-size:12px">如果追溯这个 TerminateProcess，可以发现，其调用了 Ntdll.dll 中的 NtTerminateProcess API，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后再追溯下去就可以到 ntoskrnl.exe 中的 ZwTerminateProcess 和系统服务 NtTerminateProcess 了。</span></p>
<p><span style="font-family:Courier New; font-size:12px">而这和我的上一篇博文中介绍 NtQuerySystemInformation 就是一致的了，</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>所以如果我们要实现进程保护，需要 Hook 的系统服务就是 NtTerminateProcess ~
</strong></span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>3. SSDT Hook 框架搭建：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p><span style="font-family:Courier New; font-size:12px">从上面的介绍中，我们可以知道，要想实现进程隐藏和进程保护，我们需要在 SSDT 中 Hook 两个系统服务，</span></p>
<p><span style="font-family:Courier New; font-size:12px">即 Ring0 下的 NtQuerySystemInformation 和 Ring0 下的 NtTerminateProcess，</span></p>
<p><span style="font-family:Courier New; font-size:12px">既然要实现两个 Hook 的话，我干嘛不将 SSDT Hook 写成一个框架呢，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这样的话，以后我无论是需要 Hook 哪个 SSDT 中的系统服务，我直接调用这个 SSDT 框架不就 OK 了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">免得再去重复造轮子不，所以这里就来简单介绍一下这个 SSDT 框架 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">当然这里谈得 SSDT Hook 框架可不是大伙&#30524;里的什么 .Net 框架啊，MVC 框架啊之类的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">没那么复杂，算到底也就是一个 .cpp 和一个 .h 的文件而已，然后再在其中对外公开几个 API 即 OK 了 ~
</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041809559519.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/20110904180959505.png" width="377" height="438" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">这里既是使用了 SSDT 的话，而在前一篇博文中也谈到了在 ntoskrnl.exe 中导出了 KeServiceDescriptorTable，</span></p>
<p><span style="font-family:Courier New; font-size:12px">但是内核中导出归导出，它导出有个屁用啊，别个类型啊什么的都没给你，看你怎么在你代码中使用它 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以我们首先要做的就是如何使用这个 ntoskrnl.exe 中导出的 KeServiceDescriptorTable 了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">不过好在还有 WRK(当然在反汇编，逆向工程里面那些牛的作用也是相当的给力)的帮助，</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>我们可以定义下面的代码来完成在自己的代码中使用 KeServiceDescriptorTable 这个任务：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//Name: KSYSTEM_SERVICE_TABLE 和 KSERVICE_TABLE_DESCRIPTOR                             //</span></pre>
<pre><span class="lnum">   4:  </span><span class="rem">//Descripion: 用来定义 SSDT 结构                                                       //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">   7:  </span>typedef <span class="kwrd">struct</span> _KSYSTEM_SERVICE_TABLE</pre>
<pre><span class="lnum">   8:  </span>{</pre>
<pre class="alt"><span class="lnum">   9:  </span>    PULONG  ServiceTableBase;        <span class="rem">// SSDT (System Service Dispatch Table)的基地址</span></pre>
<pre><span class="lnum">  10:  </span>    PULONG  ServiceCounterTableBase; <span class="rem">// 包含 SSDT 中每个服务被调用的次数</span></pre>
<pre class="alt"><span class="lnum">  11:  </span>    ULONG   NumberOfService;&nbsp;&nbsp;&nbsp;&nbsp; <span class="rem">// 服务函数的个数, NumberOfService * 4 就是整个地址表的大小</span></pre>
<pre><span class="lnum">  12:  </span>    ULONG   ParamTableBase;          <span class="rem">// SSPT(System Service Parameter Table)的基地址</span></pre>
<pre class="alt"><span class="lnum">  13:  </span>&nbsp;</pre>
<pre><span class="lnum">  14:  </span>} KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  17:  </span>typedef <span class="kwrd">struct</span> _KSERVICE_TABLE_DESCRIPTOR</pre>
<pre><span class="lnum">  18:  </span>{</pre>
<pre class="alt"><span class="lnum">  19:  </span>    KSYSTEM_SERVICE_TABLE   ntoskrnl; <span class="rem">// ntoskrnl.exe 的服务函数</span></pre>
<pre><span class="lnum">  20:  </span>    KSYSTEM_SERVICE_TABLE   win32k;   <span class="rem">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)</span></pre>
<pre class="alt"><span class="lnum">  21:  </span>    KSYSTEM_SERVICE_TABLE   notUsed1;</pre>
<pre><span class="lnum">  22:  </span>    KSYSTEM_SERVICE_TABLE   notUsed2;</pre>
<pre class="alt"><span class="lnum">  23:  </span>&nbsp;</pre>
<pre><span class="lnum">  24:  </span>} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</pre>
<pre class="alt"><span class="lnum">  25:  </span>&nbsp;</pre>
<pre><span class="lnum">  26:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  27:  </span><span class="rem">//导出由 ntoskrnl.exe 所导出的 SSDT</span></pre>
<pre><span class="lnum">  28:  </span><span class="kwrd">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">既然是个 SSDT Hook 框架的话，自然需要能够安装 Hook，当然也需要能够解除 Hook，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而我们拿什么来解除 Hook 呢，经过前面的介绍，我们可以知道的是，</span></p>
<p><span style="font-family:Courier New; font-size:12px">SSDT Hook 其实就是拿我们自己的 Hook 函数的地址去替换掉原来 SSDT 中保存的系统服务的地址，</span></p>
<p><span style="font-family:Courier New; font-size:12px">如果 Hook 了某个 API，那就意味着在 SSDT 中指定索引处所保存的系统服务的地址被修改为了 Hook 函数的地址，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而如果要解除这个 API 的 Hook，自然就需要将原来系统中原有的系统服务的地址写回 SSDT 指定索引处，</span></p>
<p><span style="font-family:Courier New; font-size:12px">但是我们拿什么来保存 SSDT Hook 之前的系统服务的地址呢 ?</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>由于在 32 位机器上，一个入口地址可以用 32 位来表示，也就可以使用一个 ULONG 类型来保存，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>而由于我们这个是 SSDT 框架，也就是能够随意的 Hook SSDT 中的任意系统服务，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>自然为了能成功实现 Hook 的解除，就需要将 SSDT 中在 Hook 之前的每一个系统服务的地址保存下来，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>根据上面的总结，这可以通过一个 ULONG 数组来保存就可以了 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">然后再在 Hook 任意的系统服务之前，将 SSDT 中的所有系统服务的地址保存或者说是备份到 ULONG 数组中即可 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">而后在解除 Hook 时，我们就可以从这个 ULONG 数组中取出原有系统服务的地址，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后将地址写入到 SSDT 中即可实现 Hook 解除 ~</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//定义 SSDT(系统服务描述表) 中服务个数的最大数目</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//这里定义为 1024 个，实际上在 XP SP3 是 0x0128 个</span></pre>
<pre class="alt"><span class="lnum">   3:  </span><span class="preproc">#define</span> MAX_SYSTEM_SERVICE_NUMBER 1024</pre>
<pre><span class="lnum">   4:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//用来保存 SSDT 中所有的旧的服务函数的地址</span></pre>
<pre><span class="lnum">   6:  </span>ULONG oldSysServiceAddr[MAX_SYSTEM_SERVICE_NUMBER];</pre>
</div>
<span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>
<p><span style="font-family:Courier New; font-size:12px">同时由于要实现安装 Hook，解除 Hook，所以自然也要公开两个 API，一个用来安装 Hook，一个用来解除 Hook，</span></p>
<p><span style="font-family:Courier New; font-size:12px">根据上面的这些呢，我们大致可以确定至少需要三个 API：</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//备份 SSDT 中所有系统服务的地址</span></pre>
<pre><span class="lnum">   2:  </span>VOID BackupSysServicesTable();</pre>
<pre class="alt"><span class="lnum">   3:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span><span class="rem">//安装 Hook</span></pre>
<pre class="alt"><span class="lnum">   5:  </span>NTSTATUS InstallSysServiceHook(ULONG oldService, ULONG newService);</pre>
<pre><span class="lnum">   6:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">   7:  </span><span class="rem">//解除 Hook</span></pre>
<pre><span class="lnum">   8:  </span>NTSTATUS UnInstallSysServiceHook(ULONG oldService);</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后还需要注意的是，SSDT 中保存的地址不是说你想写就可以写的，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>SSDT 在内存中是具有只读属性保护的，如果你想修改 SSDT 中的内容，你必须先要解除只读属性，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>也就是要赋予 SSDT 所在的这块内存具有可写属性才行，不然回馈你的将是一个无情的蓝屏(内存写入错误) ~</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>你给了这块内存可写属性后，你他妈的写完后总的把可写属性去掉，把别个恢复到只读属性吧 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>不然也太不厚道了，用完就不管了 ~ 所以还需要一个恢复只读属性的 API，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>综述，在 SSDT Hook 框架中又有了两个 API：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//禁止写入保护，也就是恢复到只读</span></pre>
<pre><span class="lnum">   2:  </span>VOID DisableWriteProtect(ULONG oldAttr);</pre>
<pre class="alt"><span class="lnum">   3:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span><span class="rem">//允许写入保护，也就是设置为可写</span></pre>
<pre class="alt"><span class="lnum">   5:  </span>VOID EnableWriteProtect(PULONG pOldAttr);</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">然后呢下面就将上面的这些个 API 的实现代码给贴出来，个人觉得自己的代码风&#26684;还算比较好的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">应该还是看得下去吧(当然这只是我现在的观点，说不准再过段时间回头来看这些代码就会感慨这代码是给人看的嘛) ~
</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>#include <span class="str">&quot;SSDTHook.h&quot;</span></pre>
<pre><span class="lnum">   2:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//Name: VOID DisableWriteProtect()                                                     //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">   7:  </span><span class="rem">//Descripion: 用来去掉内存的可写属性，从而实现内存只读                                 //</span></pre>
<pre><span class="lnum">   8:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">   9:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">  10:  </span>VOID DisableWriteProtect(ULONG oldAttr)</pre>
<pre class="alt"><span class="lnum">  11:  </span>{</pre>
<pre><span class="lnum">  12:  </span>    _asm</pre>
<pre class="alt"><span class="lnum">  13:  </span>    {</pre>
<pre><span class="lnum">  14:  </span>        mov eax, oldAttr</pre>
<pre class="alt"><span class="lnum">  15:  </span>        mov cr0, eax</pre>
<pre><span class="lnum">  16:  </span>        sti;</pre>
<pre class="alt"><span class="lnum">  17:  </span>    }</pre>
<pre><span class="lnum">  18:  </span>}</pre>
<pre class="alt"><span class="lnum">  19:  </span>&nbsp;</pre>
<pre><span class="lnum">  20:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  21:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">  22:  </span><span class="rem">//Name: VOID EnableWriteProtect()                                                      //</span></pre>
<pre class="alt"><span class="lnum">  23:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  24:  </span><span class="rem">//Descripion: 用来去掉内存的只读保护，从而实现可以写内存                               //</span></pre>
<pre class="alt"><span class="lnum">  25:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  26:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  27:  </span>VOID EnableWriteProtect(PULONG pOldAttr)</pre>
<pre><span class="lnum">  28:  </span>{</pre>
<pre class="alt"><span class="lnum">  29:  </span>    ULONG uAttr; </pre>
<pre><span class="lnum">  30:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  31:  </span>    _asm </pre>
<pre><span class="lnum">  32:  </span>    { </pre>
<pre class="alt"><span class="lnum">  33:  </span>        cli;</pre>
<pre><span class="lnum">  34:  </span>        mov  eax, cr0; </pre>
<pre class="alt"><span class="lnum">  35:  </span>        mov  uAttr, eax; </pre>
<pre><span class="lnum">  36:  </span>        and  eax, 0FFFEFFFFh; <span class="rem">// CR0 16 BIT = 0 </span></pre>
<pre class="alt"><span class="lnum">  37:  </span>        mov  cr0, eax; </pre>
<pre><span class="lnum">  38:  </span>    }; </pre>
<pre class="alt"><span class="lnum">  39:  </span>&nbsp;</pre>
<pre><span class="lnum">  40:  </span>    <span class="rem">//保存原有的 CRO 属性 </span></pre>
<pre class="alt"><span class="lnum">  41:  </span>    *pOldAttr = uAttr; </pre>
<pre><span class="lnum">  42:  </span>}</pre>
<pre class="alt"><span class="lnum">  43:  </span>&nbsp;</pre>
<pre><span class="lnum">  44:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  45:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">  46:  </span><span class="rem">//Name: VOID BackupSysServicesTable()                                                  //</span></pre>
<pre class="alt"><span class="lnum">  47:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  48:  </span><span class="rem">//Descripion: 备份 SSDT 中原有服务的地址，因为在解除 Hook 时需要还原 SSDT 中原有地址   //</span></pre>
<pre class="alt"><span class="lnum">  49:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  50:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  51:  </span>VOID BackupSysServicesTable()</pre>
<pre><span class="lnum">  52:  </span>{</pre>
<pre class="alt"><span class="lnum">  53:  </span>    ULONG i;</pre>
<pre><span class="lnum">  54:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  55:  </span>    <span class="kwrd">for</span>(i = 0; (i &lt; KeServiceDescriptorTable-&gt;ntoskrnl.NumberOfService) &amp;&amp; (i &lt; MAX_SYSTEM_SERVICE_NUMBER); i&#43;&#43;)</pre>
<pre><span class="lnum">  56:  </span>    {</pre>
<pre class="alt"><span class="lnum">  57:  </span>        oldSysServiceAddr[i] = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[i];</pre>
<pre><span class="lnum">  58:  </span>        <span class="rem">//oldSysServiceAddr[i] = *(PULONG)((ULONG)KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase &#43; 4 * i);</span></pre>
<pre class="alt"><span class="lnum">  59:  </span>&nbsp;</pre>
<pre><span class="lnum">  60:  </span>        KdPrint((<span class="str">&quot;\Function Information { Number: 0x%04X , Address: %08X}&quot;</span>, i, oldSysServiceAddr[i]));</pre>
<pre class="alt"><span class="lnum">  61:  </span>    }</pre>
<pre><span class="lnum">  62:  </span>}</pre>
<pre class="alt"><span class="lnum">  63:  </span>&nbsp;</pre>
<pre><span class="lnum">  64:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  65:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">  66:  </span><span class="rem">//Name: NTSTATUS InstallSysServiceHook()                                               //</span></pre>
<pre class="alt"><span class="lnum">  67:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  68:  </span><span class="rem">//Descripion: 实现 Hook 的安装，主要是在 SSDT 中用 newService 来替换掉 oldService      //</span></pre>
<pre class="alt"><span class="lnum">  69:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">  70:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  71:  </span>NTSTATUS InstallSysServiceHook(ULONG oldService, ULONG newService)</pre>
<pre><span class="lnum">  72:  </span>{</pre>
<pre class="alt"><span class="lnum">  73:  </span>    ULONG uOldAttr = 0;</pre>
<pre><span class="lnum">  74:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  75:  </span>    EnableWriteProtect(&amp;uOldAttr);</pre>
<pre><span class="lnum">  76:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  77:  </span>    SYSCALL_FUNCTION(oldService) = newService;</pre>
<pre><span class="lnum">  78:  </span>    <span class="rem">//KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(oldService)] = newService;</span></pre>
<pre class="alt"><span class="lnum">  79:  </span>&nbsp;</pre>
<pre><span class="lnum">  80:  </span>    DisableWriteProtect(uOldAttr);</pre>
<pre class="alt"><span class="lnum">  81:  </span>&nbsp;</pre>
<pre><span class="lnum">  82:  </span>    <span class="kwrd">return</span> STATUS_SUCCESS;</pre>
<pre class="alt"><span class="lnum">  83:  </span>}</pre>
<pre><span class="lnum">  84:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  85:  </span>&nbsp;</pre>
<pre><span class="lnum">  86:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  87:  </span><span class="rem">//Name: NTSTATUS UnInstallSysServiceHook()                                             //</span></pre>
<pre><span class="lnum">  88:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">  89:  </span><span class="rem">//Descripion: 实现 Hook 的解除，主要是在 SSDT 中用备份下的服务地址来替换掉 oldService  //</span></pre>
<pre><span class="lnum">  90:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">  91:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">  92:  </span>NTSTATUS UnInstallSysServiceHook(ULONG oldService)</pre>
<pre class="alt"><span class="lnum">  93:  </span>{</pre>
<pre><span class="lnum">  94:  </span>    ULONG uOldAttr = 0;</pre>
<pre class="alt"><span class="lnum">  95:  </span>&nbsp;</pre>
<pre><span class="lnum">  96:  </span>    EnableWriteProtect(&amp;uOldAttr);</pre>
<pre class="alt"><span class="lnum">  97:  </span>&nbsp;</pre>
<pre><span class="lnum">  98:  </span>    SYSCALL_FUNCTION(oldService) = oldSysServiceAddr[SYSCALL_INDEX(oldService)];</pre>
<pre><span class="lnum"> 100:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 101:  </span>    DisableWriteProtect(uOldAttr);</pre>
<pre><span class="lnum"> 102:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 103:  </span>    <span class="kwrd">return</span> STATUS_SUCCESS;</pre>
<pre><span class="lnum"> 104:  </span>}</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>可以注意到上面有两个很重要的宏，即 SYSCALL_FUNCTION 和 SYSCALL_INDEX 宏，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>关于这两个宏的具体作用，可以看注释的 ~
</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//根据 Zw_ServiceFunction 获取 Zw_ServiceFunction 在 SSDT 中所对应的服务的索引号</span></pre>
<pre><span class="lnum">   2:  </span><span class="preproc">#define</span> SYSCALL_INDEX(ServiceFunction) (*(PULONG)((PUCHAR)ServiceFunction &#43; 1))</pre>
<pre class="alt"><span class="lnum">   3:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//根据 Zw_ServiceFunction 来获得服务在 SSDT 中的索引号，</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//然后再通过该索引号来获取 Nt_ServiceFunction的地址</span></pre>
<pre class="alt"><span class="lnum">   7:  </span><span class="preproc">#define</span> SYSCALL_FUNCTION(ServiceFunction) </pre>
<pre><span class="lnum">   8:  </span>        KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(ServiceFunction)]</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>4. Ring0 实现进程隐藏：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">有了 SSDT Hook 框架后，其实要实现进程的隐藏是很简单的了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">根据前面的介绍，要想实现进程隐藏，你可以通过 Hook NtQuerySystemInformation 来实现，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以剩下的任务就只需要在我们自己的 Hook 处理函数中来将进程隐藏掉就 OK 了 ~</span></p>
<p><span style="font-family:Courier New; font-size:12px">由于 NtQuerySystemInformation 这个系统服务在 ntddk.h 中并没有被声明，</span></p>
<p><span style="font-family:Courier New; font-size:12px">虽然这个系统服务在 ntoskrnl.exe 中被导出了，但是没有它的声明，我们仍然是无法使用的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以我们就需要手动的声明一下这个函数 ~ </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">还有需要注意的是，我们在前面知道，在 ntoskrnl.exe 中实质上是存在 ZwQuerySystemInformation
</span></p>
<p><span style="font-family:Courier New; font-size:12px">以及 NtQuerySystemInformation 这两个 API 的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而在 SSDT Hook 中我们是根据 ZwQuerySystemInformation
</span></p>
<p><span style="font-family:Courier New; font-size:12px">来推算出在 SSDT 中保存有 NtQuerySystemInformation 的地址所在的索引号的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">关于这个，你可以查看 SYSCALL_INDEX 这个宏来再次确认一下 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后有了这个索引号，我们才可以进行对 NtQuerySystemInformation 系统服务的 Hook，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以在声明时，我们需要声明两个 API，当然如果这些 API 在 ntddk.h 中声明了就不需要了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">但是由于 ZwQuerySystemInformation 和 NtQuerySystemInformation 在 ntddk.h 中都没有声明，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以需要在我们自己的代码中手动声明 ~ </span>
</p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation (</pre>
<pre><span class="lnum">   2:  </span>    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</pre>
<pre class="alt"><span class="lnum">   3:  </span>    __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</pre>
<pre><span class="lnum">   4:  </span>    __in ULONG SystemInformationLength,</pre>
<pre class="alt"><span class="lnum">   5:  </span>    __out_opt PULONG ReturnLength</pre>
<pre><span class="lnum">   6:  </span>    );</pre>
<pre class="alt"><span class="lnum">   7:  </span>&nbsp;</pre>
<pre><span class="lnum">   8:  </span>typedef NTSTATUS (* NTQUERYSYSTEMINFORMATION)(</pre>
<pre class="alt"><span class="lnum">   9:  </span>    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</pre>
<pre><span class="lnum">  10:  </span>    __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</pre>
<pre class="alt"><span class="lnum">  11:  </span>    __in ULONG SystemInformationLength,</pre>
<pre><span class="lnum">  12:  </span>    __out_opt PULONG ReturnLength</pre>
<pre class="alt"><span class="lnum">  13:  </span>    );</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">(暂停一下，肚子饿了 ~ 吃饭去 ~ )</span></p>
<p><span style="font-family:Courier New; font-size:12px">(好，饭给吃了，酒也喝了，精神亢奋中，现在咱继续哈 ~ 嘿嘿 ~)</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>完成了这些声明后，我们就可以来实现自己的 NtQuerySystemInformation Hook 函数了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在这个 Hook 函数中，我们需要对我们感兴趣的进程进行隐藏 ~
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">然后这里需要注意的是，我是如何来实现对进程隐藏的，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">首先我是判断这个进程的 ID 是否是需要隐藏的进程 ID，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">这是通过 ValidateProcessNeedHide 函数来判断的 ~ 这个函数会在后面给出 ~
</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">注意结合代码中的注释来看(虽然注释比较少 ~ 嘿嘿 ~ )</span></strong></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>NTSTATUS HookNtQuerySystemInformation (</pre>
<pre><span class="lnum">   2:  </span>    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</pre>
<pre class="alt"><span class="lnum">   3:  </span>    __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</pre>
<pre><span class="lnum">   4:  </span>    __in ULONG SystemInformationLength,</pre>
<pre class="alt"><span class="lnum">   5:  </span>    __out_opt PULONG ReturnLength</pre>
<pre><span class="lnum">   6:  </span>    );</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//Name: NTSTATUS HookNtQuerySystemInformation()                                        //</span></pre>
<pre class="alt"><span class="lnum">   3:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   4:  </span><span class="rem">//Descripion: 自定义的 NtQuerySystemInformation，用来实现 Hook Kernel API              //</span></pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">   7:  </span>NTSTATUS HookNtQuerySystemInformation (</pre>
<pre><span class="lnum">   8:  </span>    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</pre>
<pre class="alt"><span class="lnum">   9:  </span>    __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</pre>
<pre><span class="lnum">  10:  </span>    __in ULONG SystemInformationLength,</pre>
<pre class="alt"><span class="lnum">  11:  </span>    __out_opt PULONG ReturnLength</pre>
<pre><span class="lnum">  12:  </span>    )</pre>
<pre class="alt"><span class="lnum">  13:  </span>{</pre>
<pre><span class="lnum">  14:  </span>    NTSTATUS rtStatus;</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span>    pOldNtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)</pre>
<pre class="alt"><span class="lnum">  17:  </span>        oldSysServiceAddr[SYSCALL_INDEX(ZwQuerySystemInformation)];</pre>
<pre><span class="lnum">  18:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  19:  </span>    rtStatus = pOldNtQuerySystemInformation(SystemInformationClass, SystemInformation, </pre>
<pre><span class="lnum">  20:  </span>        SystemInformationLength, ReturnLength);</pre>
<pre class="alt"><span class="lnum">  21:  </span>    <span class="kwrd">if</span>(NT_SUCCESS(rtStatus))</pre>
<pre><span class="lnum">  22:  </span>    {</pre>
<pre class="alt"><span class="lnum">  23:  </span>        <span class="kwrd">if</span>(SystemProcessInformation == SystemInformationClass)</pre>
<pre><span class="lnum">  24:  </span>        {</pre>
<pre class="alt"><span class="lnum">  25:  </span>            PSYSTEM_PROCESS_INFORMATION pPrevProcessInfo = NULL;</pre>
<pre><span class="lnum">  26:  </span>            PSYSTEM_PROCESS_INFORMATION pCurrProcessInfo = </pre>
<pre class="alt"><span class="lnum">  27:  </span>                (PSYSTEM_PROCESS_INFORMATION)SystemInformation; </pre>
<pre><span class="lnum">  28:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  29:  </span>            <span class="kwrd">while</span>(pCurrProcessInfo != NULL)</pre>
<pre><span class="lnum">  30:  </span>            {</pre>
<pre class="alt"><span class="lnum">  31:  </span>                <span class="rem">//获取当前遍历的 SYSTEM_PROCESS_INFORMATION 节点的进程名称和进程 ID</span></pre>
<pre><span class="lnum">  32:  </span>                ULONG uPID = (ULONG)pCurrProcessInfo-&gt;UniqueProcessId;</pre>
<pre class="alt"><span class="lnum">  33:  </span>                UNICODE_STRING strTmpProcessName = pCurrProcessInfo-&gt;ImageName;</pre>
<pre><span class="lnum">  34:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  35:  </span>                <span class="rem">//判断当前遍历的这个进程是否为需要隐藏的进程</span></pre>
<pre><span class="lnum">  36:  </span>                <span class="kwrd">if</span>(ValidateProcessNeedHide(uPID) != -1)</pre>
<pre class="alt"><span class="lnum">  37:  </span>                {</pre>
<pre><span class="lnum">  38:  </span>                    <span class="kwrd">if</span>(pPrevProcessInfo)</pre>
<pre class="alt"><span class="lnum">  39:  </span>                    {</pre>
<pre><span class="lnum">  40:  </span>                        <span class="kwrd">if</span>(pCurrProcessInfo-&gt;NextEntryOffset)</pre>
<pre class="alt"><span class="lnum">  41:  </span>                        {</pre>
<pre><span class="lnum">  42:  </span>                            <span class="rem">//将当前这个进程(即要隐藏的进程)从 SystemInformation 中摘除(更改链表偏移指针实现)</span></pre>
<pre class="alt"><span class="lnum">  43:  </span>                            pPrevProcessInfo-&gt;NextEntryOffset &#43;= pCurrProcessInfo-&gt;NextEntryOffset;</pre>
<pre><span class="lnum">  44:  </span>                        }</pre>
<pre class="alt"><span class="lnum">  45:  </span>                        <span class="kwrd">else</span></pre>
<pre><span class="lnum">  46:  </span>                        {</pre>
<pre class="alt"><span class="lnum">  47:  </span>                            <span class="rem">//说明当前要隐藏的这个进程是进程链表中的最后一个</span></pre>
<pre><span class="lnum">  48:  </span>                            pPrevProcessInfo-&gt;NextEntryOffset = 0;</pre>
<pre class="alt"><span class="lnum">  49:  </span>                        }</pre>
<pre><span class="lnum">  50:  </span>                    }</pre>
<pre class="alt"><span class="lnum">  51:  </span>                    <span class="kwrd">else</span></pre>
<pre><span class="lnum">  52:  </span>                    {</pre>
<pre class="alt"><span class="lnum">  53:  </span>                        <span class="rem">//第一个遍历到得进程就是需要隐藏的进程</span></pre>
<pre><span class="lnum">  54:  </span>                        <span class="kwrd">if</span>(pCurrProcessInfo-&gt;NextEntryOffset)</pre>
<pre class="alt"><span class="lnum">  55:  </span>                        {</pre>
<pre><span class="lnum">  56:  </span>                            (PCHAR)SystemInformation &#43;= pCurrProcessInfo-&gt;NextEntryOffset;</pre>
<pre class="alt"><span class="lnum">  57:  </span>                        }</pre>
<pre><span class="lnum">  58:  </span>                        <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum">  59:  </span>                        {</pre>
<pre><span class="lnum">  60:  </span>                            SystemInformation = NULL;</pre>
<pre class="alt"><span class="lnum">  61:  </span>                        }</pre>
<pre><span class="lnum">  62:  </span>                    }</pre>
<pre class="alt"><span class="lnum">  63:  </span>                }</pre>
<pre><span class="lnum">  64:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  65:  </span>                <span class="rem">//遍历下一个 SYSTEM_PROCESS_INFORMATION 节点</span></pre>
<pre><span class="lnum">  66:  </span>                pPrevProcessInfo = pCurrProcessInfo;</pre>
<pre class="alt"><span class="lnum">  67:  </span>&nbsp;</pre>
<pre><span class="lnum">  68:  </span>                <span class="rem">//遍历结束</span></pre>
<pre class="alt"><span class="lnum">  69:  </span>                <span class="kwrd">if</span>(pCurrProcessInfo-&gt;NextEntryOffset)</pre>
<pre><span class="lnum">  70:  </span>                {</pre>
<pre class="alt"><span class="lnum">  71:  </span>                    pCurrProcessInfo = (PSYSTEM_PROCESS_INFORMATION)</pre>
<pre><span class="lnum">  72:  </span>                        (((PCHAR)pCurrProcessInfo) &#43; pCurrProcessInfo-&gt;NextEntryOffset);</pre>
<pre class="alt"><span class="lnum">  73:  </span>                }</pre>
<pre><span class="lnum">  74:  </span>                <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum">  75:  </span>                {</pre>
<pre><span class="lnum">  76:  </span>                    pCurrProcessInfo = NULL;</pre>
<pre class="alt"><span class="lnum">  77:  </span>                }</pre>
<pre><span class="lnum">  78:  </span>            }</pre>
<pre class="alt"><span class="lnum">  79:  </span>        }</pre>
<pre><span class="lnum">  80:  </span>    }</pre>
<pre class="alt"><span class="lnum">  81:  </span>    <span class="kwrd">return</span> rtStatus;</pre>
<pre><span class="lnum">  82:  </span>}</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">既然有了自己的 Hook NtQuerySystemInformation 了，自然我们就可以通过利用 SSDT 框架来实现 Hook 了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这部分的代码其实是最简单的，因为我只需要在 DriverEntry 中 Hook 掉 NtQuerySystemInformation 即可，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这里需要注意的是，在执行 Hook 之前需要备份一次 SSDT，即在 DriverEntry 中最先需要备份 SSDT ~</span></p>
<p><span style="font-family:Courier New; font-size:12px">当然为了保证系统的安全以及其他诸多方面，我们在 DriverUnload 中会将 Hook 解除掉 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>从下面的代码中，我们看到在安装 Hook 和解除 Hook 时参数传递进去的是 ZwQuerySystemInformation，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>这样很有可能会让很多朋友认为我们在 Ring0 下的 Hook 的是 ZwQuerySystemInformation，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>如果你这样认为的话，那就大错特错了，确实在 Google 上搜索出的一大堆关于 SSDT Hook 中，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>很多文章都说是 Hook 的 ZwQuerySystemInformation，而事实上这是大错特错的，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>我们这里传入 ZwQuerySystemInformation ，是因为我们需要调用 SYS_INDEX(ZwQuerySystemInformation)
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>来获得 NtQuerySystemInformation 在 SSDT 中的地址所在的索引号，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后我们根据这个索引号来 Hook NtQuerySystemInformation，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>认识到这一点是非常重要的，因为我一开始也认为是 Hook 的 ZwQuerySystemInformation，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong><span style="color:#0000ff">从而导致蓝屏了 n 次，在这里非常鄙视那些把文章从别处拷贝过来也不加验证就乱发表的 ~ 害死人 ~ 当然也要怪自己懒 ~</span></strong>
</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041810011575.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041810059430.png" width="1047" height="130" style="border-right-width:0px; padding-left:0px; width:952px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041810072169.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109041810136908.png" width="1066" height="411" style="border-right-width:0px; padding-left:0px; width:952px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<span style="font-family:Courier New; font-size:12px"></span>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>5. Ring0 实现进程保护：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">有了上面实现进程隐藏的基础，要再来实现进程保护，其实也就是过过场子了 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">进程保护呢，上面也说了，是要 Hook NtTermianteProcess 这个系统服务 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">由于 ZwTerminateProcess 呢，在 ntddk.h 中已经声明了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">所以在我们自己的代码中就不需要声明 ZwTermianteProcess 了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而只需要声明 NtTerminateProcess 以及 Hook 函数就 OK 了 ~
</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>typedef NTSTATUS (* NTTERMINATEPROCESS)(</pre>
<pre><span class="lnum">   2:  </span>    __in_opt HANDLE ProcessHandle,</pre>
<pre class="alt"><span class="lnum">   3:  </span>    __in NTSTATUS ExitStatus</pre>
<pre><span class="lnum">   4:  </span>    );</pre>
<pre class="alt"><span class="lnum">   5:  </span>&nbsp;</pre>
<pre><span class="lnum">   6:  </span>NTSTATUS HookNtTerminateProcess(</pre>
<pre class="alt"><span class="lnum">   7:  </span>    __in_opt HANDLE ProcessHandle,</pre>
<pre><span class="lnum">   8:  </span>    __in NTSTATUS ExitStatus</pre>
<pre class="alt"><span class="lnum">   9:  </span>    );</pre>
<pre><span class="lnum">  10:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  11:  </span>NTTERMINATEPROCESS pOldNtTerminateProcess;</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">至于安装 Hook 以及卸载 Hook ，都可以根据进程隐藏中的代码来完成，因为有了 SSDT Hook 框架，</span></p>
<p><span style="font-family:Courier New; font-size:12px">这一切也就变得很简单了，只要在 DriverEntry 中 InstallHook ，然后再在 DriverUnload 中 UnInstallHook 即 OK ~</span></p>
<p><span style="font-family:Courier New; font-size:12px">下面我们重点来看一看我们自己的 Hook NtTerminateProcess 中是如何实现进程保护的 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>进程保护呢其实也是比较简单的，因为从上面一层的调用会传递一个进程句柄下来，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>而后我们可以根据这个进程句柄来获得进程的 EPROCESS 对象(进程位于执行体层得对象)，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>通过这个 EPROCESS 对象，我们就可以获得这个请求被结束的进程的 PID，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>我们再判断这个 PID 是否是我们已经保护了的 PID，如果是的话，直接返回一个请求被拒绝即可，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong><span style="color:#0000ff">而如果这个 PID 未被保护，自然我们就交给原来的 NtTerminateProcess 处理即可 ~</span></strong>
</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//Name: NTSTATUS HookNtTerminateProcess()                                              //</span></pre>
<pre class="alt"><span class="lnum">   3:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   4:  </span><span class="rem">//Descripion: 自定义的 NtTerminateProcess，用来实现 Hook Kernel API                    //</span></pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">   7:  </span>NTSTATUS HookNtTerminateProcess(</pre>
<pre><span class="lnum">   8:  </span>    __in_opt HANDLE ProcessHandle,</pre>
<pre class="alt"><span class="lnum">   9:  </span>    __in NTSTATUS ExitStatus</pre>
<pre><span class="lnum">  10:  </span>    )</pre>
<pre class="alt"><span class="lnum">  11:  </span>{</pre>
<pre><span class="lnum">  12:  </span>    ULONG uPID;</pre>
<pre class="alt"><span class="lnum">  13:  </span>    NTSTATUS rtStatus;</pre>
<pre><span class="lnum">  14:  </span>    PCHAR pStrProcName;</pre>
<pre class="alt"><span class="lnum">  15:  </span>    PEPROCESS pEProcess;</pre>
<pre><span class="lnum">  16:  </span>    ANSI_STRING strProcName;</pre>
<pre class="alt"><span class="lnum">  17:  </span>&nbsp;</pre>
<pre><span class="lnum">  18:  </span>    <span class="rem">//通过进程句柄来获得该进程所对应的 FileObject 对象，由于这里是进程对象，自然获得的是 EPROCESS 对象</span></pre>
<pre class="alt"><span class="lnum">  19:  </span>    rtStatus = ObReferenceObjectByHandle(ProcessHandle, </pre>
<pre><span class="lnum">  20:  </span>        FILE_READ_DATA, NULL, KernelMode, &amp;pEProcess, NULL);</pre>
<pre class="alt"><span class="lnum">  21:  </span>    <span class="kwrd">if</span>(!NT_SUCCESS(rtStatus))</pre>
<pre><span class="lnum">  22:  </span>    {</pre>
<pre class="alt"><span class="lnum">  23:  </span>        <span class="kwrd">return</span> rtStatus;</pre>
<pre><span class="lnum">  24:  </span>    }</pre>
<pre class="alt"><span class="lnum">  25:  </span>&nbsp;</pre>
<pre><span class="lnum">  26:  </span>    <span class="rem">//保存 SSDT 中原来的 NtTerminateProcess 地址</span></pre>
<pre class="alt"><span class="lnum">  27:  </span>    pOldNtTerminateProcess = </pre>
<pre><span class="lnum">  28:  </span>        (NTTERMINATEPROCESS)oldSysServiceAddr[SYSCALL_INDEX(ZwTerminateProcess)];</pre>
<pre class="alt"><span class="lnum">  29:  </span>&nbsp;</pre>
<pre><span class="lnum">  30:  </span>    <span class="rem">//通过该函数可以获取到进程名称和进程 ID，该函数在内核中实质是导出的(在 WRK 中可以看到)</span></pre>
<pre class="alt"><span class="lnum">  31:  </span>    <span class="rem">//但是 ntddk.h 中并没有到处，所以需要自己声明才能使用</span></pre>
<pre><span class="lnum">  32:  </span>    uPID = (ULONG)PsGetProcessId(pEProcess);</pre>
<pre class="alt"><span class="lnum">  33:  </span>    pStrProcName = (PCHAR)PsGetProcessImageFileName(pEProcess);</pre>
<pre><span class="lnum">  34:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  35:  </span>    <span class="rem">//通过进程名来初始化一个 ASCII 字符串</span></pre>
<pre><span class="lnum">  36:  </span>    RtlInitAnsiString(&amp;strProcName, pStrProcName);</pre>
<pre class="alt"><span class="lnum">  37:  </span>&nbsp;</pre>
<pre><span class="lnum">  38:  </span>    <span class="kwrd">if</span>(ValidateProcessNeedProtect(uPID) != -1)</pre>
<pre class="alt"><span class="lnum">  39:  </span>    {</pre>
<pre><span class="lnum">  40:  </span>        <span class="rem">//确保调用者进程能够结束(这里主要是指 taskmgr.exe)</span></pre>
<pre class="alt"><span class="lnum">  41:  </span>        <span class="kwrd">if</span>(uPID != (ULONG)PsGetProcessId(PsGetCurrentProcess()))</pre>
<pre><span class="lnum">  42:  </span>        {</pre>
<pre class="alt"><span class="lnum">  43:  </span>            <span class="rem">//如果该进程是所保护的的进程的话，则返回权限不够的异常即可</span></pre>
<pre><span class="lnum">  44:  </span>            <span class="kwrd">return</span> STATUS_ACCESS_DENIED;</pre>
<pre class="alt"><span class="lnum">  45:  </span>        }</pre>
<pre><span class="lnum">  46:  </span>    }</pre>
<pre class="alt"><span class="lnum">  47:  </span>&nbsp;</pre>
<pre><span class="lnum">  48:  </span>    <span class="rem">//对于非保护的进程可以直接调用原来 SSDT 中的 NtTerminateProcess 来结束进程</span></pre>
<pre class="alt"><span class="lnum">  49:  </span>    rtStatus = pOldNtTerminateProcess(ProcessHandle, ExitStatus);</pre>
<pre><span class="lnum">  50:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  51:  </span>    <span class="kwrd">return</span> rtStatus;</pre>
<pre><span class="lnum">  52:  </span>}</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>6. 隐藏进程列表和保护进程列表的维护：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">由于需要隐藏的进程以及需要被保护的进程都是由应用程序传递进来的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">也就是说这个内核程序是需要和应用程序通信的，自然就需要创建一个 Device，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后我就采用了简单的 DeviceIoControl 来实现了内核程序和应用程序的通信，</span></p>
<p><span style="font-family:Courier New; font-size:12px">对于需要隐藏的进程或者是需要保护的进程，其由应用程序通过 DeviceIoControl 来将这个进程的 PID 传递给内核程序，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后在内核程序中呢，维护了两个数组，一个数组用来存放需要隐藏的进程的 PID，</span></p>
<p><span style="font-family:Courier New; font-size:12px">另外一个数组自然就是用来存放需要保护的进程的 PID，</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>ULONG g_PIDHideArray[MAX_PROCESS_ARRARY_LENGTH];</pre>
<pre><span class="lnum">   2:  </span>ULONG g_PIDProtectArray[MAX_PROCESS_ARRARY_LENGTH];</pre>
<pre class="alt"><span class="lnum">   3:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span>ULONG g_currHideArrayLen = 0;</pre>
<pre class="alt"><span class="lnum">   5:  </span>ULONG g_currProtectArrayLen = 0;</pre>
</div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:Courier New; font-size:12px">为了维护上面的这两个数组呢，又衍生出了几个 API，即实现对数组中的 PID 进行增删查 ~
</span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//验证 uPID 所代表的进程是否存在于隐藏进程列表中，即判断 uPID 这个进程是否需要隐藏</span></pre>
<pre><span class="lnum">   2:  </span>ULONG ValidateProcessNeedHide(ULONG uPID);</pre>
<pre class="alt"><span class="lnum">   3:  </span>&nbsp;</pre>
<pre><span class="lnum">   4:  </span><span class="rem">//验证 uPID 所代表的进程是否存在于保护进程列表中，即判断 uPID 这个进程是否需要保护</span></pre>
<pre class="alt"><span class="lnum">   5:  </span>ULONG ValidateProcessNeedProtect(ULONG uPID);</pre>
<pre><span class="lnum">   6:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">   7:  </span><span class="rem">//往隐藏进程列表中插入 uPID</span></pre>
<pre><span class="lnum">   8:  </span>ULONG InsertHideProcess(ULONG uPID);</pre>
<pre class="alt"><span class="lnum">   9:  </span>&nbsp;</pre>
<pre><span class="lnum">  10:  </span><span class="rem">//从隐藏进程列表中移除 uPID</span></pre>
<pre class="alt"><span class="lnum">  11:  </span>ULONG RemoveHideProcess(ULONG uPID);</pre>
<pre><span class="lnum">  12:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  13:  </span><span class="rem">//往保护进程列表中插入 uPID</span></pre>
<pre><span class="lnum">  14:  </span>ULONG InsertProtectProcess(ULONG uPID);</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span><span class="rem">//从隐藏进程列表中移除 uPID</span></pre>
<pre class="alt"><span class="lnum">  17:  </span>ULONG RemoveProtectProcess(ULONG uPID);</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>对于前面谈及的 HookNtQuerySystemInformation 和 HookNtTerminateProcess 的话，</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">需要判断一个进程是否是需要被保护或者需要被隐藏的进程就是通过上面的数组来完成的，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">即判断一个进程是否需要被隐藏时，只需要判断这个进程在隐藏列表中是否存在即可，</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">而对于实现进程保护的话，道理也是一样的 ~
</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>上面说过，应用程序和内核程序的通信是通过 DeviceIoControl 来完成的，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>下面我们就来看看 DeviceIoControl 的代码：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//Name: NTSTATUS SSDT01DeviceIoControlDispatcher()                                     //</span></pre>
<pre class="alt"><span class="lnum">   3:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   4:  </span><span class="rem">//Descripion: 分发函数                                                                 //</span></pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">   7:  </span>NTSTATUS SSDT01DeviceIoControlDispatcher(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)</pre>
<pre><span class="lnum">   8:  </span>{</pre>
<pre class="alt"><span class="lnum">   9:  </span>    NTSTATUS rtStatus;</pre>
<pre><span class="lnum">  10:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  11:  </span>    ULONG uPID;</pre>
<pre><span class="lnum">  12:  </span>    ULONG uInLen;</pre>
<pre class="alt"><span class="lnum">  13:  </span>    ULONG uOutLen;</pre>
<pre><span class="lnum">  14:  </span>    ULONG uCtrlCode;</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span>    PCHAR pInBuffer;</pre>
<pre class="alt"><span class="lnum">  17:  </span>&nbsp;</pre>
<pre><span class="lnum">  18:  </span>    PIO_STACK_LOCATION pStack;    </pre>
<pre class="alt"><span class="lnum">  19:  </span>&nbsp;</pre>
<pre><span class="lnum">  20:  </span>    uPID = 0;</pre>
<pre class="alt"><span class="lnum">  21:  </span>    rtStatus = STATUS_SUCCESS;</pre>
<pre><span class="lnum">  22:  </span>    pStack = IoGetCurrentIrpStackLocation(pIrp);</pre>
<pre class="alt"><span class="lnum">  23:  </span>&nbsp;</pre>
<pre><span class="lnum">  24:  </span>    uInLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</pre>
<pre class="alt"><span class="lnum">  25:  </span>    uOutLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;</pre>
<pre><span class="lnum">  26:  </span>    uCtrlCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;</pre>
<pre class="alt"><span class="lnum">  27:  </span>&nbsp;</pre>
<pre><span class="lnum">  28:  </span>    <span class="rem">//使用缓冲区方式与应用程序进行通信</span></pre>
<pre class="alt"><span class="lnum">  29:  </span>    pInBuffer = (PCHAR)pIrp-&gt;AssociatedIrp.SystemBuffer;</pre>
<pre><span class="lnum">  30:  </span>    </pre>
<pre class="alt"><span class="lnum">  31:  </span>    <span class="kwrd">if</span>(uInLen &gt;= 4)</pre>
<pre><span class="lnum">  32:  </span>    {</pre>
<pre class="alt"><span class="lnum">  33:  </span>        <span class="rem">//stdlib.h(atol = Array To LONG)</span></pre>
<pre><span class="lnum">  34:  </span>        uPID = atol(pInBuffer);</pre>
<pre class="alt"><span class="lnum">  35:  </span>&nbsp;</pre>
<pre><span class="lnum">  36:  </span>        <span class="kwrd">switch</span>(uCtrlCode)</pre>
<pre class="alt"><span class="lnum">  37:  </span>        {</pre>
<pre><span class="lnum">  38:  </span>        <span class="kwrd">case</span> IO_INSERT_PROTECT_PROCESS:</pre>
<pre class="alt"><span class="lnum">  39:  </span>            {</pre>
<pre><span class="lnum">  40:  </span>                <span class="kwrd">if</span>(InsertProtectProcess(uPID) == FALSE)</pre>
<pre class="alt"><span class="lnum">  41:  </span>                {</pre>
<pre><span class="lnum">  42:  </span>                    rtStatus = STATUS_PROCESS_IS_TERMINATING;</pre>
<pre class="alt"><span class="lnum">  43:  </span>                }</pre>
<pre><span class="lnum">  44:  </span>                <span class="kwrd">break</span>;</pre>
<pre class="alt"><span class="lnum">  45:  </span>            }</pre>
<pre><span class="lnum">  46:  </span>        <span class="kwrd">case</span> IO_REMOVE_PROTECT_PROCESS:</pre>
<pre class="alt"><span class="lnum">  47:  </span>            {</pre>
<pre><span class="lnum">  48:  </span>                <span class="kwrd">if</span>(RemoveProtectProcess(uPID) == FALSE)</pre>
<pre class="alt"><span class="lnum">  49:  </span>                {</pre>
<pre><span class="lnum">  50:  </span>                    rtStatus = STATUS_PROCESS_IS_TERMINATING;</pre>
<pre class="alt"><span class="lnum">  51:  </span>                }</pre>
<pre><span class="lnum">  52:  </span>                <span class="kwrd">break</span>;</pre>
<pre class="alt"><span class="lnum">  53:  </span>            }</pre>
<pre><span class="lnum">  54:  </span>        <span class="kwrd">case</span> IO_INSERT_HIDE_PROCESS:</pre>
<pre class="alt"><span class="lnum">  55:  </span>            {</pre>
<pre><span class="lnum">  56:  </span>                <span class="kwrd">if</span>(InsertHideProcess(uPID) == FALSE)</pre>
<pre class="alt"><span class="lnum">  57:  </span>                {</pre>
<pre><span class="lnum">  58:  </span>                    rtStatus = STATUS_PROCESS_IS_TERMINATING;</pre>
<pre class="alt"><span class="lnum">  59:  </span>                }</pre>
<pre><span class="lnum">  60:  </span>                <span class="kwrd">break</span>;</pre>
<pre class="alt"><span class="lnum">  61:  </span>            }</pre>
<pre><span class="lnum">  62:  </span>        <span class="kwrd">case</span> IO_REMOVE_HIDE_PROCESS:</pre>
<pre class="alt"><span class="lnum">  63:  </span>            {</pre>
<pre><span class="lnum">  64:  </span>                <span class="kwrd">if</span>(RemoveHideProcess(uPID) == FALSE)</pre>
<pre class="alt"><span class="lnum">  65:  </span>                {</pre>
<pre><span class="lnum">  66:  </span>                    rtStatus = STATUS_PROCESS_IS_TERMINATING;</pre>
<pre class="alt"><span class="lnum">  67:  </span>                }</pre>
<pre><span class="lnum">  68:  </span>                <span class="kwrd">break</span>;</pre>
<pre class="alt"><span class="lnum">  69:  </span>            }</pre>
<pre><span class="lnum">  70:  </span>        <span class="kwrd">default</span>:</pre>
<pre class="alt"><span class="lnum">  71:  </span>            {</pre>
<pre><span class="lnum">  72:  </span>                rtStatus = STATUS_INVALID_VARIANT;</pre>
<pre class="alt"><span class="lnum">  73:  </span>                <span class="kwrd">break</span>;</pre>
<pre><span class="lnum">  74:  </span>            }</pre>
<pre class="alt"><span class="lnum">  75:  </span>        }</pre>
<pre><span class="lnum">  76:  </span>    }</pre>
<pre class="alt"><span class="lnum">  77:  </span>    <span class="kwrd">else</span></pre>
<pre><span class="lnum">  78:  </span>    {</pre>
<pre class="alt"><span class="lnum">  79:  </span>        rtStatus = STATUS_INVALID_PARAMETER;</pre>
<pre><span class="lnum">  80:  </span>    }</pre>
<pre class="alt"><span class="lnum">  81:  </span>    </pre>
<pre><span class="lnum">  82:  </span>    <span class="rem">//输出信息总是为空，即该驱动程序不返回输出信息</span></pre>
<pre class="alt"><span class="lnum">  83:  </span>    pIrp-&gt;IoStatus.Status = rtStatus;</pre>
<pre><span class="lnum">  84:  </span>    pIrp-&gt;IoStatus.Information = 0;</pre>
<pre class="alt"><span class="lnum">  85:  </span>    IoCompleteRequest(pIrp, IO_NO_INCREMENT);</pre>
<pre><span class="lnum">  86:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  87:  </span>    <span class="kwrd">return</span> rtStatus;</pre>
<pre><span class="lnum">  88:  </span>}</pre>
</div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>7. 小结：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">这篇博文呢，是承接前一篇博文《进程隐藏与进程保护(SSDT Hook 实现)(一)》来的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">前面的博文主要介绍了 SSDT 是个什么东西，以及我们做内核 Hook 的一些基础，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而这篇博文则完整的介绍了 SSDT Hook 的具体实现，其中涉及到了很多底层的知识的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">对于绝大部分的代码呢，大伙是可以参考代码来进行理解的，而后我会将内核部分的代码先公开出来 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">本来呢是打算将这个 SSDT Hook 做两篇博文就给结束得了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">不过第二篇博文写了这么长了，但是在应用程序中的实现都还没有开始介绍，</span></p>
<p><span style="font-family:Courier New; font-size:12px">而今晚真的又太晚了，再写下去天就亮了，还说要尽量不熬夜的 ~ 唉 ~ 算了，权当周末给自己找个借口吧 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">下一篇博文将介绍的是如何在应用程序中获取到所有的进程啊，以及应用程序如何和内核程序设备进行通信之类的知识，</span></p>
<p><span style="font-family:Courier New; font-size:12px">知识重点是放在 Ring3 了，其中不会涉及到很多 Ring0 的内容了 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>开发工具以及环境搭建：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">Visual Studio 2010 &#43; VirtualDDK &#43; WDK &#43; VMware &#43; Windows Service 2003 SP1，</span><span style="font-family:Courier New; font-size:12px">至于具体环境的搭建，</span></p>
<p><span style="font-family:Courier New; font-size:12px">可以参考我的博文<strong>《驱动程序环境搭建(VS2010 &#43; WDK &#43; VirtualDDK &#43; VMware)》</strong>，</span><span style="font-family:Courier New; font-size:12px">博文地址如下：</span></p>
<p><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/07/31/2122755.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/07/31/2122755.html</span></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong><u>下载
</u></strong></span><a target="_blank" href="http://files.cnblogs.com/BoyXiao/SSDT01.zip"><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong>SSDT Hook Source Code</strong></span></a><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong><u>
</u></strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"></span></p>
<p><span style="font-family:Courier New; font-size:12px"></span></p>
<p><span style="font-family:Courier New; font-size:12px"><span style="font-family:Verdana">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>和前一篇文章一样，我将我近来遇到的一些疑问放到博文的最后面，看是否有看官遇到过，如果有遇到过的，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>还请不吝赐教 ~ 在下感激不尽 ~
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>疑问 1：
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在 .Net WinForm 中，我有一个定时器，然后又有一个按钮，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>那么对应的就有一个定时器 Tick 处理事件，</strong></span><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>按钮也会有一个 Click 事件，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>考虑在多核处理器上，</strong></span><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>有没有这样一种可能，按钮的 Click 事件和 Tick 处理事件并发执行 ?</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">如果有的话，大伙一般都是如何做处理的 ?</span></strong></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>疑问 2：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>大家都有用过 SVN 的，当我们安装好客户端工具 TortoiseSVN 后，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>每次启动 PC ，均会有一个 TSVNCache.exe 的进程随 PC 自动启动，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>请教一下大家这个进程是如何启动的 ?</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong><br>
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong></strong></span></p>
<h1 class="postTitle"><a target="_blank" id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/05/2168115.html">进程隐藏与进程保护（SSDT Hook 实现）（三）</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div id="cnblogs_post_body">
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>文章目录：</strong></span></p>
<p><span style="font-family:微软雅黑"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>1. 引子：</strong></span></p>
<p><strong><span style="font-family:微软雅黑; font-size:12px; color:#0000ff">2. 获取当前系统下所有进程：</span></strong></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>3. 服务管理（安装，启动，停止，卸载）：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>4. 应用程序和内核程序通信：</strong></span></p>
<p><span style="font-family:微软雅黑; font-size:12px; color:#0000ff"><strong>5. 小结：</strong></span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>1. 引子：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>关于这个 SSDT Hook 实现进程隐藏和进程保护呢，这是最后一篇博文了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>在文章的结尾处呢你可以下载到整个项目的实例程序以及代码，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>程序可以在 XP、Server、Win7 上运行的，当然我是说的 32 位操作系统。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">《进程隐藏与进程保护(SSDT Hook 实现)(一)》呢把 SSDT Hook 的原理说得差不多了，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>博文地址：</strong></span><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html"><span style="font-family:Courier New; font-size:12px">http://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html</span></a></p>
<p><span style="font-family:Courier New; font-size:12px">《进程隐藏与进程保护(SSDT Hook 实现)(二)》则把 SSDT Hook 的实现说得差不多了，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>博文地址：</strong><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/09/04/2166596.html">http://www.cnblogs.com/BoyXiao/archive/2011/09/04/2166596.html</a></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">这一篇博文介绍的则是在 Ring3 下编写 MFC 应用程序，并且让应用程序与内核程序通信，</span></p>
<p><span style="font-family:Courier New; font-size:12px">即由应用程序将需要隐藏的进程或者是需要保护的进程的 PID 传递给内核程序，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后在内核程序中就会将传递进来的这个 PID 进行隐藏或者保护 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">在这里再给出这个应用程序的一张截图：</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109052303087302.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109052303211720.png" width="854" height="670" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>2. 获取当前系统下所有进程：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p><span style="font-family:Courier New; font-size:12px">前面提到过，要想获取到系统下的所有进程，有三种方法，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第一种即是使用 ToolHelp 来获取，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第二种则是使用 PSAPI 来获取，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第三种则是使用 ntdll.dll 中的未文档化的 NtQuerySystemInformation 之类的 API 来获取(比较麻烦)。</span></p>
<p><span style="font-family:Courier New; font-size:12px">而在这里我使用最简单的方式，即通过 PSAPI 中的 EnumProcesses 这个 API 来获取，</span></p>
<p><span style="font-family:Courier New; font-size:12px">EnumProcesses API 可以获取到当前系统下所有进程的 PID，并且将 PID 存放在作为输出参数的数组当中，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>其原型如下（可以看 MSDN）：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>BOOL WINAPI EnumProcesses(</pre>
<pre><span class="lnum">   2:  </span>  __out         DWORD* pProcessIds,</pre>
<pre class="alt"><span class="lnum">   3:  </span>  __in          DWORD cb,</pre>
<pre><span class="lnum">   4:  </span>  __out         DWORD* pBytesReturned</pre>
<pre class="alt"><span class="lnum">   5:  </span>);</pre>
<pre><span class="lnum">   6:  </span>&nbsp;</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>代码中使用(将获取到所有的 PID，然后将 PID 保存到 vector 容器中)：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//遍历当前所有的进程，并且将进程 ID 填充到容器 vectorPID 中</span></pre>
<pre><span class="lnum">   2:  </span><span class="kwrd">void</span> CSSDTProcessDlg::FillPIDVector()</pre>
<pre class="alt"><span class="lnum">   3:  </span>{</pre>
<pre><span class="lnum">   4:  </span>    DWORD dwPIDArray[MAX_PROCESS_COUNT];</pre>
<pre class="alt"><span class="lnum">   5:  </span>    DWORD dwNeededBytes;</pre>
<pre><span class="lnum">   6:  </span>    DWORD dwProcCount;</pre>
<pre class="alt"><span class="lnum">   7:  </span>&nbsp;</pre>
<pre><span class="lnum">   8:  </span>    dwNeededBytes = 0;</pre>
<pre class="alt"><span class="lnum">   9:  </span>    dwProcCount = 0;</pre>
<pre><span class="lnum">  10:  </span>    memset(dwPIDArray, 0, <span class="kwrd">sizeof</span>(DWORD) * MAX_PROCESS_COUNT);</pre>
<pre class="alt"><span class="lnum">  11:  </span>    <span class="kwrd">if</span>(NULL != EnumProcesses(dwPIDArray, <span class="kwrd">sizeof</span>(dwPIDArray), &amp;dwNeededBytes))</pre>
<pre><span class="lnum">  12:  </span>    {</pre>
<pre class="alt"><span class="lnum">  13:  </span>        dwProcCount = dwNeededBytes / <span class="kwrd">sizeof</span>(DWORD);</pre>
<pre><span class="lnum">  14:  </span>    }</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span>    BubbleSort(dwPIDArray, dwProcCount);</pre>
<pre class="alt"><span class="lnum">  17:  </span>&nbsp;</pre>
<pre><span class="lnum">  18:  </span>    ClearVector();</pre>
<pre class="alt"><span class="lnum">  19:  </span>    <span class="kwrd">for</span>(<span class="kwrd">int</span> i=0; i&lt;dwProcCount; i&#43;&#43;)</pre>
<pre><span class="lnum">  20:  </span>    {</pre>
<pre class="alt"><span class="lnum">  21:  </span>        PROCESS_BIND procBind;</pre>
<pre><span class="lnum">  22:  </span>        procBind.dwPID = dwPIDArray[i];</pre>
<pre class="alt"><span class="lnum">  23:  </span>        <span class="kwrd">if</span>(dwPIDArray[i] == 0)</pre>
<pre><span class="lnum">  24:  </span>        {</pre>
<pre class="alt"><span class="lnum">  25:  </span>            procBind.state = ProcessStateUnknown;</pre>
<pre><span class="lnum">  26:  </span>        }</pre>
<pre class="alt"><span class="lnum">  27:  </span>        <span class="kwrd">else</span></pre>
<pre><span class="lnum">  28:  </span>        {</pre>
<pre class="alt"><span class="lnum">  29:  </span>            procBind.state = ProcessStateGeneral;</pre>
<pre><span class="lnum">  30:  </span>        }</pre>
<pre class="alt"><span class="lnum">  31:  </span>        <span class="kwrd">this</span>-&gt;m_vctAllProcess.push_back(procBind);</pre>
<pre><span class="lnum">  32:  </span>    }</pre>
<pre class="alt"><span class="lnum">  33:  </span>}</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>3. 服务管理（安装，启动，停止，卸载）：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">在 Windows 内核程序中，现在大体可以分为三类了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">第一类是 NT 式驱动程序；</span></p>
<p><span style="font-family:Courier New; font-size:12px">第二类为 WDM 驱动程序；</span></p>
<p><span style="font-family:Courier New; font-size:12px">第三类为 WDF 驱动程序；</span></p>
<p><span style="font-family:Courier New; font-size:12px">其中，对于 NT 式驱动程序，其安装方式是很简单的，因为你可以将 NT 式驱动程序看做一个服务，</span></p>
<p><span style="font-family:Courier New; font-size:12px">既然是服务的话，自然在 Windows 中可以通过 SCM API 来完成其安装，启动，停止和卸载等功能 ~</span></p>
<p><span style="font-family:Courier New; font-size:12px">而至于 WDM 和 WDF 的话，如果其中涉及到了设备的话，还必须使用 INF 文件来实现安装 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px">而我们前面的那个 SSDT 内核程序就是基于 NT 式的驱动程序，所以可以通过 SCM API 来实现上面的这些功能，</span></p>
<p><span style="font-family:Courier New; font-size:12px">至于如何使用 SCM API 来完成服务的安装、启动、停止和卸载功能的话，</span></p>
<p><span style="font-family:Courier New; font-size:12px">可以参见笔者的另外一篇博文</span><span style="font-family:Courier New; font-size:12px">《Windows 服务(附服务开发辅助工具)》，</span></p>
<p><span style="font-family:Courier New; font-size:12px"><strong>博文地址为：</strong><a target="_blank" href="http://www.cnblogs.com/BoyXiao/archive/2011/08/07/2130208.html">http://www.cnblogs.com/BoyXiao/archive/2011/08/07/2130208.html</a></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>下面就只是将服务的安装 API、启动 API、停止 API 和卸载 API 贴出来了 ~</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">至于这些代码的细细道来的话，可以参加上面给出的那篇博文的 ~
</span></strong></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre><span class="lnum">   2:  </span><span class="rem">//Name: bool InstallSvc()                                                              //</span></pre>
<pre class="alt"><span class="lnum">   3:  </span><span class="rem">//                                                                                     //</span></pre>
<pre><span class="lnum">   4:  </span><span class="rem">//Descripion: 安装服务                                                                 //</span></pre>
<pre class="alt"><span class="lnum">   5:  </span><span class="rem">//            lpszSvcName 为服务名称，                                                 //</span></pre>
<pre><span class="lnum">   6:  </span><span class="rem">//            lpszDisplay 为显示在服务控制管理器中的名称，                             //</span></pre>
<pre class="alt"><span class="lnum">   7:  </span><span class="rem">//            lpszSvcBinaryPath 为服务映像文件所在路径，                               //</span></pre>
<pre><span class="lnum">   8:  </span><span class="rem">//            dwSvcType 为服务类型                                                     //</span></pre>
<pre class="alt"><span class="lnum">   9:  </span><span class="rem">//            dwStartType 为服务启动类型                                               //</span></pre>
<pre><span class="lnum">  10:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  11:  </span><span class="kwrd">bool</span> CSSDTProcessDlg::InstallSvc(LPTSTR lpszSvcName, LPTSTR lpszDisplayName,</pre>
<pre><span class="lnum">  12:  </span>        LPTSTR lpszSvcBinaryPath, DWORD dwSvcType, DWORD dwStartType)</pre>
<pre class="alt"><span class="lnum">  13:  </span>{</pre>
<pre><span class="lnum">  14:  </span>    SC_HANDLE hSCM = NULL;</pre>
<pre class="alt"><span class="lnum">  15:  </span>    SC_HANDLE hSvc = NULL;</pre>
<pre><span class="lnum">  16:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  17:  </span>    AdjustProcessTokenPrivilege();</pre>
<pre><span class="lnum">  18:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  19:  </span>    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);</pre>
<pre><span class="lnum">  20:  </span>    <span class="kwrd">if</span>(NULL == hSCM)</pre>
<pre class="alt"><span class="lnum">  21:  </span>    {</pre>
<pre><span class="lnum">  22:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;InstallSvc - OpenSCManager Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  23:  </span>&nbsp;</pre>
<pre><span class="lnum">  24:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum">  25:  </span>    }</pre>
<pre><span class="lnum">  26:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  27:  </span>    <span class="kwrd">for</span>(<span class="kwrd">int</span> i = 0; i &lt; 3 &amp;&amp; (NULL == hSvc); i&#43;&#43;)</pre>
<pre><span class="lnum">  28:  </span>    {</pre>
<pre class="alt"><span class="lnum">  29:  </span>        <span class="rem">//SERVICE_WIN32_OWN_PROCESS  | SERVICE_INTERACTIVE_PROCESS</span></pre>
<pre><span class="lnum">  30:  </span>        hSvc = CreateService(hSCM, lpszSvcName, lpszDisplayName, SERVICE_ALL_ACCESS, </pre>
<pre class="alt"><span class="lnum">  31:  </span>            dwSvcType, dwStartType, SERVICE_ERROR_NORMAL, </pre>
<pre><span class="lnum">  32:  </span>            lpszSvcBinaryPath, NULL, NULL, NULL, NULL, NULL);</pre>
<pre class="alt"><span class="lnum">  33:  </span>        <span class="kwrd">if</span>(NULL != hSvc)</pre>
<pre><span class="lnum">  34:  </span>        {</pre>
<pre class="alt"><span class="lnum">  35:  </span>            <span class="kwrd">if</span>(NULL != hSvc)</pre>
<pre><span class="lnum">  36:  </span>            {</pre>
<pre class="alt"><span class="lnum">  37:  </span>                CloseServiceHandle(hSvc);</pre>
<pre><span class="lnum">  38:  </span>            }</pre>
<pre class="alt"><span class="lnum">  39:  </span>            CloseServiceHandle(hSCM);</pre>
<pre><span class="lnum">  40:  </span>            <span class="kwrd">return</span> TRUE;</pre>
<pre class="alt"><span class="lnum">  41:  </span>        }</pre>
<pre><span class="lnum">  42:  </span>    }</pre>
<pre class="alt"><span class="lnum">  43:  </span>&nbsp;</pre>
<pre><span class="lnum">  44:  </span>    OutputErrorMessage(TEXT(<span class="str">&quot;InstallSvc - CreateService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  45:  </span>&nbsp;</pre>
<pre><span class="lnum">  46:  </span>    CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum">  47:  </span>&nbsp;</pre>
<pre><span class="lnum">  48:  </span>    <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum">  49:  </span>}</pre>
<pre><span class="lnum">  50:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  51:  </span>&nbsp;</pre>
<pre><span class="lnum">  52:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  53:  </span><span class="rem">//Name: bool UnInstallSvc()                                                            //</span></pre>
<pre><span class="lnum">  54:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">  55:  </span><span class="rem">//Descripion: 实现卸载服务                                                             //</span></pre>
<pre><span class="lnum">  56:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  57:  </span><span class="kwrd">bool</span> CSSDTProcessDlg::UnInstallSvc(LPTSTR lpszSvcName)</pre>
<pre><span class="lnum">  58:  </span>{</pre>
<pre class="alt"><span class="lnum">  59:  </span>    SC_HANDLE hSCM = NULL;</pre>
<pre><span class="lnum">  60:  </span>    SC_HANDLE hSvc = NULL;</pre>
<pre class="alt"><span class="lnum">  61:  </span>    <span class="kwrd">bool</span> rtResult = FALSE;</pre>
<pre><span class="lnum">  62:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  63:  </span>    AdjustProcessTokenPrivilege();</pre>
<pre><span class="lnum">  64:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  65:  </span>    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);</pre>
<pre><span class="lnum">  66:  </span>    <span class="kwrd">if</span>(NULL == hSCM)</pre>
<pre class="alt"><span class="lnum">  67:  </span>    {</pre>
<pre><span class="lnum">  68:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;UnInstallSvc - OpenSCManager Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  69:  </span>&nbsp;</pre>
<pre><span class="lnum">  70:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum">  71:  </span>    }</pre>
<pre><span class="lnum">  72:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  73:  </span>    hSvc = OpenService(hSCM, lpszSvcName, SERVICE_ALL_ACCESS);</pre>
<pre><span class="lnum">  74:  </span>    <span class="kwrd">if</span>(NULL == hSvc)</pre>
<pre class="alt"><span class="lnum">  75:  </span>    {</pre>
<pre><span class="lnum">  76:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;UnInstallSvc - OpenService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  77:  </span>&nbsp;</pre>
<pre><span class="lnum">  78:  </span>        CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum">  79:  </span>&nbsp;</pre>
<pre><span class="lnum">  80:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum">  81:  </span>    }</pre>
<pre><span class="lnum">  82:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  83:  </span>    rtResult = DeleteService(hSvc);</pre>
<pre><span class="lnum">  84:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  85:  </span>    CloseServiceHandle(hSvc);</pre>
<pre><span class="lnum">  86:  </span>    CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum">  87:  </span>&nbsp;</pre>
<pre><span class="lnum">  88:  </span>    <span class="kwrd">return</span> rtResult;</pre>
<pre class="alt"><span class="lnum">  89:  </span>}</pre>
<pre><span class="lnum">  90:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  91:  </span>&nbsp;</pre>
<pre><span class="lnum">  92:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  93:  </span><span class="rem">//Name: bool StartSvc()                                                                //</span></pre>
<pre><span class="lnum">  94:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum">  95:  </span><span class="rem">//Descripion: 实现启动服务                                                             //</span></pre>
<pre><span class="lnum">  96:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum">  97:  </span><span class="kwrd">bool</span> CSSDTProcessDlg::StartSvc(LPTSTR lpszSvcName)</pre>
<pre><span class="lnum">  98:  </span>{</pre>
<pre class="alt"><span class="lnum">  99:  </span>    SC_HANDLE hSCM = NULL;</pre>
<pre><span class="lnum"> 100:  </span>    SC_HANDLE hSvc = NULL;</pre>
<pre class="alt"><span class="lnum"> 101:  </span>    <span class="kwrd">bool</span> rtResult = FALSE;</pre>
<pre><span class="lnum"> 102:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 103:  </span>    AdjustProcessTokenPrivilege();</pre>
<pre><span class="lnum"> 104:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 105:  </span>    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);</pre>
<pre><span class="lnum"> 106:  </span>    <span class="kwrd">if</span>(NULL == hSCM)</pre>
<pre class="alt"><span class="lnum"> 107:  </span>    {</pre>
<pre><span class="lnum"> 108:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;StartSvc - OpenSCManager Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 109:  </span>&nbsp;</pre>
<pre><span class="lnum"> 110:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum"> 111:  </span>    }</pre>
<pre><span class="lnum"> 112:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 113:  </span>    hSvc = OpenService(hSCM, lpszSvcName, SERVICE_ALL_ACCESS);</pre>
<pre><span class="lnum"> 114:  </span>    <span class="kwrd">if</span>(NULL == hSvc)</pre>
<pre class="alt"><span class="lnum"> 115:  </span>    {</pre>
<pre><span class="lnum"> 116:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;StartSvc - OpenService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 117:  </span>&nbsp;</pre>
<pre><span class="lnum"> 118:  </span>        CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum"> 119:  </span>&nbsp;</pre>
<pre><span class="lnum"> 120:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum"> 121:  </span>    }</pre>
<pre><span class="lnum"> 122:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 123:  </span>    rtResult = StartService(hSvc, NULL, NULL);</pre>
<pre><span class="lnum"> 124:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 125:  </span>    CloseServiceHandle(hSvc);</pre>
<pre><span class="lnum"> 126:  </span>    CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum"> 127:  </span>&nbsp;</pre>
<pre><span class="lnum"> 128:  </span>    <span class="kwrd">if</span>(FALSE == rtResult)</pre>
<pre class="alt"><span class="lnum"> 129:  </span>    {</pre>
<pre><span class="lnum"> 130:  </span>        <span class="kwrd">if</span>(ERROR_SERVICE_ALREADY_RUNNING == GetLastError())</pre>
<pre class="alt"><span class="lnum"> 131:  </span>        {</pre>
<pre><span class="lnum"> 132:  </span>            <span class="kwrd">return</span> TRUE;</pre>
<pre class="alt"><span class="lnum"> 133:  </span>        }</pre>
<pre><span class="lnum"> 134:  </span>        <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum"> 135:  </span>        {</pre>
<pre><span class="lnum"> 136:  </span>            OutputErrorMessage(TEXT(<span class="str">&quot;StartSvc - StartService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 137:  </span>&nbsp;</pre>
<pre><span class="lnum"> 138:  </span>            <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum"> 139:  </span>        }</pre>
<pre><span class="lnum"> 140:  </span>    }</pre>
<pre class="alt"><span class="lnum"> 141:  </span>    <span class="kwrd">else</span></pre>
<pre><span class="lnum"> 142:  </span>    {</pre>
<pre class="alt"><span class="lnum"> 143:  </span>        <span class="kwrd">return</span> TRUE;</pre>
<pre><span class="lnum"> 144:  </span>    }</pre>
<pre class="alt"><span class="lnum"> 145:  </span>}</pre>
<pre><span class="lnum"> 146:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 147:  </span>&nbsp;</pre>
<pre><span class="lnum"> 148:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum"> 149:  </span><span class="rem">//Name: bool StopSvc()                                                                 //</span></pre>
<pre><span class="lnum"> 150:  </span><span class="rem">//                                                                                     //</span></pre>
<pre class="alt"><span class="lnum"> 151:  </span><span class="rem">//Descripion: 实现停止服务                                                             //</span></pre>
<pre><span class="lnum"> 152:  </span><span class="rem">//=====================================================================================//</span></pre>
<pre class="alt"><span class="lnum"> 153:  </span><span class="kwrd">bool</span> CSSDTProcessDlg::StopSvc(LPTSTR lpszSvcName)</pre>
<pre><span class="lnum"> 154:  </span>{</pre>
<pre class="alt"><span class="lnum"> 155:  </span>    SC_HANDLE hSCM = NULL;</pre>
<pre><span class="lnum"> 156:  </span>    SC_HANDLE hSvc = NULL;</pre>
<pre class="alt"><span class="lnum"> 157:  </span>    <span class="kwrd">bool</span> rtResult = FALSE;</pre>
<pre><span class="lnum"> 158:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 159:  </span>    SERVICE_STATUS svcStatus;</pre>
<pre><span class="lnum"> 160:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 161:  </span>    AdjustProcessTokenPrivilege();</pre>
<pre><span class="lnum"> 162:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 163:  </span>    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);</pre>
<pre><span class="lnum"> 164:  </span>    <span class="kwrd">if</span>(NULL == hSCM)</pre>
<pre class="alt"><span class="lnum"> 165:  </span>    {</pre>
<pre><span class="lnum"> 166:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;StopSvc - OpenSCManager Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 167:  </span>&nbsp;</pre>
<pre><span class="lnum"> 168:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum"> 169:  </span>    }</pre>
<pre><span class="lnum"> 170:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 171:  </span>    hSvc = OpenService(hSCM, lpszSvcName, SERVICE_ALL_ACCESS);</pre>
<pre><span class="lnum"> 172:  </span>    <span class="kwrd">if</span>(NULL == hSvc)</pre>
<pre class="alt"><span class="lnum"> 173:  </span>    {</pre>
<pre><span class="lnum"> 174:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;StopSvc - OpenService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 175:  </span>&nbsp;</pre>
<pre><span class="lnum"> 176:  </span>        CloseServiceHandle(hSCM);</pre>
<pre class="alt"><span class="lnum"> 177:  </span>&nbsp;</pre>
<pre><span class="lnum"> 178:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre class="alt"><span class="lnum"> 179:  </span>    }</pre>
<pre><span class="lnum"> 180:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 181:  </span>    rtResult = ControlService(hSvc, SERVICE_CONTROL_STOP, &amp;svcStatus);</pre>
<pre><span class="lnum"> 182:  </span>    <span class="kwrd">if</span>(rtResult == FALSE)</pre>
<pre class="alt"><span class="lnum"> 183:  </span>    {</pre>
<pre><span class="lnum"> 184:  </span>        OutputErrorMessage(TEXT(<span class="str">&quot;StopSvc - ControlService Failed , Error Code Is %d , Error Message Is %s !&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 185:  </span>    }</pre>
<pre><span class="lnum"> 186:  </span>    CloseServiceHandle(hSvc);</pre>
<pre class="alt"><span class="lnum"> 187:  </span>    CloseServiceHandle(hSCM);</pre>
<pre><span class="lnum"> 188:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum"> 189:  </span>    <span class="kwrd">return</span> rtResult;</pre>
<pre><span class="lnum"> 190:  </span>}</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>那么服务的安装和启动放在那里比较合适，而服务的关闭和卸载又放在那里比较合适呢 ?</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>由于这个应用程序采用 MFC 开发，自然可以在 OnInitDialog()中安装和启动服务比较合适，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>而后可以在对话框类的析构函数中关闭和卸载掉服务 ~
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#0000ff">安装和启动服务：</span></strong></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>    wstring wStrSysPath = GetSysFilePath();</pre>
<pre><span class="lnum">   2:  </span>    BOOL bResult = InstallSvc(((LPTSTR)(LPCTSTR)SSDT01_SERVICE_NAME), </pre>
<pre class="alt"><span class="lnum">   3:  </span>                              ((LPTSTR)(LPCTSTR)SSDT01_SERVICE_NAME), </pre>
<pre><span class="lnum">   4:  </span>                              ((LPTSTR)(LPCTSTR)wStrSysPath.c_str()), </pre>
<pre class="alt"><span class="lnum">   5:  </span>                              SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START);</pre>
<pre><span class="lnum">   6:  </span>    <span class="kwrd">if</span>(FALSE == bResult)</pre>
<pre class="alt"><span class="lnum">   7:  </span>    {</pre>
<pre><span class="lnum">   8:  </span>        MessageBox(_TEXT(<span class="str">&quot; Install SSDT Service Failed , Application Auto Exit !  &quot;</span>),</pre>
<pre class="alt"><span class="lnum">   9:  </span>                   _TEXT(<span class="str">&quot;Application Error&quot;</span>), MB_OK | MB_ICONSTOP);</pre>
<pre><span class="lnum">  10:  </span>        CDialogEx::OnCancel();        </pre>
<pre class="alt"><span class="lnum">  11:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre><span class="lnum">  12:  </span>    }</pre>
<pre class="alt"><span class="lnum">  13:  </span>    <span class="kwrd">else</span></pre>
<pre><span class="lnum">  14:  </span>    {</pre>
<pre class="alt"><span class="lnum">  15:  </span>        bResult = StartSvc(SSDT01_SERVICE_NAME);</pre>
<pre><span class="lnum">  16:  </span>        <span class="kwrd">if</span>(FALSE == bResult)</pre>
<pre class="alt"><span class="lnum">  17:  </span>        {</pre>
<pre><span class="lnum">  18:  </span>            MessageBox(_TEXT(<span class="str">&quot; Start SSDT Service Failed , Application Auto Exit !  &quot;</span>), </pre>
<pre class="alt"><span class="lnum">  19:  </span>                       _TEXT(<span class="str">&quot;Application Error&quot;</span>), MB_OK | MB_ICONSTOP);</pre>
<pre><span class="lnum">  20:  </span>            CDialogEx::OnCancel();</pre>
<pre class="alt"><span class="lnum">  21:  </span>            <span class="kwrd">return</span> FALSE;</pre>
<pre><span class="lnum">  22:  </span>        }</pre>
<pre class="alt"><span class="lnum">  23:  </span>    }</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>停止并且将服务卸载掉：
</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>    ~CSSDTProcessDlg()</pre>
<pre><span class="lnum">   2:  </span>    {</pre>
<pre class="alt"><span class="lnum">   3:  </span>        <span class="rem">//在析构函数中关闭 SSDT 设备句柄</span></pre>
<pre><span class="lnum">   4:  </span>        <span class="kwrd">if</span>(<span class="kwrd">this</span>-&gt;m_hDevice)</pre>
<pre class="alt"><span class="lnum">   5:  </span>        {</pre>
<pre><span class="lnum">   6:  </span>            CloseHandle(<span class="kwrd">this</span>-&gt;m_hDevice);</pre>
<pre class="alt"><span class="lnum">   7:  </span>        }</pre>
<pre><span class="lnum">   8:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">   9:  </span>        <span class="rem">//当发生析构函数时，停止服务并且卸载服务</span></pre>
<pre><span class="lnum">  10:  </span>        StopSvc(SSDT01_SERVICE_NAME);</pre>
<pre class="alt"><span class="lnum">  11:  </span>        UnInstallSvc(SSDT01_SERVICE_NAME);</pre>
<pre><span class="lnum">  12:  </span>    }</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New"><span style="font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp; </span></p>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>4. 应用程序和内核程序通信：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">由前面的第二篇博文，可以知道，应用程序和内核程序的通信我是通过 DeviceIoControl 来完成的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">开发过内核程序的都清楚，应用程序和内核程序的通信最普遍的也就通过三个 API 来实现，</span></p>
<p><span style="font-family:Courier New; font-size:12px">一个 ReadFile，一个 WriteFile，一个 DeviceIoContrl，</span></p>
<p><span style="font-family:Courier New; font-size:12px">当然其中属 DeviceIoControl 功能最为强大，完全可以用其替换掉 ReadFile 和 WriteFile，</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>DeviceIoControl 原型(详细信息可以参考 MSDN)：</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>BOOL WINAPI DeviceIoControl(</pre>
<pre><span class="lnum">   2:  </span>  __in          HANDLE hDevice,</pre>
<pre class="alt"><span class="lnum">   3:  </span>  __in          DWORD dwIoControlCode,</pre>
<pre><span class="lnum">   4:  </span>  __in          LPVOID lpInBuffer,</pre>
<pre class="alt"><span class="lnum">   5:  </span>  __in          DWORD nInBufferSize,</pre>
<pre><span class="lnum">   6:  </span>  __out         LPVOID lpOutBuffer,</pre>
<pre class="alt"><span class="lnum">   7:  </span>  __in          DWORD nOutBufferSize,</pre>
<pre><span class="lnum">   8:  </span>  __out         LPDWORD lpBytesReturned,</pre>
<pre class="alt"><span class="lnum">   9:  </span>  __in          LPOVERLAPPED lpOverlapped</pre>
<pre><span class="lnum">  10:  </span>);</pre>
<pre class="alt"><span class="lnum">  11:  </span>&nbsp;</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">至于如何实现应用程序和内核程序的通信的话，在我的 Demo 中是这样做处理的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">首先在 OnInitDialog 事件中通过 CreateFile 打开我们所安装的服务中创建的设备，</span></p>
<p><span style="font-family:Courier New; font-size:12px">(在 NT 式驱动程序中我创建了一个设备，这个设备用来实现应用程序和内核程序的通信)，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后在对话框类中保存有一个全局变量，这个全局变量即代表所打开的这个设备的句柄，</span></p>
<p><a target="_blank" href="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109052303225723.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/BoyXiao/201109/201109052303249858.png" width="635" height="206" style="border-right-width:0px; padding-left:0px; padding-right:0px; display:inline; border-top-width:0px; border-bottom-width:0px; border-left-width:0px; padding-top:0px"></a></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>既然这个全局变量是保存的我们的设备的句柄，自然我们需要来获取到设备的句柄，并且将句柄赋&#20540;给该全局变量，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>而这个呢，又是在 OnInitDialog 中完成的 ~
</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span>    <span class="kwrd">this</span>-&gt;m_hDevice = CreateFile(SSDT01_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, </pre>
<pre><span class="lnum">   2:  </span>                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</pre>
<pre class="alt"><span class="lnum">   3:  </span>    <span class="kwrd">if</span>(INVALID_HANDLE_VALUE == <span class="kwrd">this</span>-&gt;m_hDevice)</pre>
<pre><span class="lnum">   4:  </span>    {</pre>
<pre class="alt"><span class="lnum">   5:  </span>        MessageBox(_TEXT(<span class="str">&quot; Open SSDT Device Failed , Application Auto Exit !  &quot;</span>), </pre>
<pre><span class="lnum">   6:  </span>                   _TEXT(<span class="str">&quot;Application Error&quot;</span>), MB_OK | MB_ICONSTOP);</pre>
<pre class="alt"><span class="lnum">   7:  </span>&nbsp;</pre>
<pre><span class="lnum">   8:  </span>        CDialogEx::OnCancel();</pre>
<pre class="alt"><span class="lnum">   9:  </span>        <span class="kwrd">return</span> FALSE;</pre>
<pre><span class="lnum">  10:  </span>    }</pre>
</div>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>有了这个设备句柄，我们就可以通过其来实现和内核程序的通信了，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>因为通过在应用程序中调用 DeviceIoControl 可以产生 IRP_MJ_DEVICE_CONTROL 的 IRP，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>然后该 IRP 可以被驱动程序中的 DeviceIoControl 分发函数所处理 ~
</strong></span></p>
<p><strong><span style="font-family:Courier New; font-size:12px; color:#ff0000">我们的应用程序只需要将我们所要隐藏或者是需要保护的进程的 PID 通过 DeviceIoControl 传递给内核程序即可 !!!</span></strong></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>所以我们在应用程序中只需要调用 DeviceIoContrl 即可 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>下面给出的代码比较凌乱(重点请看 DeviceIoControl 的调用)</strong></span></p>
<div class="csharpcode">
<pre class="alt"><span class="lnum">   1:  </span><span class="rem">//隐藏进程或者取消对进程的隐藏</span></pre>
<pre><span class="lnum">   2:  </span><span class="kwrd">void</span> CSSDTProcessDlg::OnBnClickedBtnHideorunhide()</pre>
<pre class="alt"><span class="lnum">   3:  </span>{</pre>
<pre><span class="lnum">   4:  </span>    <span class="kwrd">int</span> nIndex;</pre>
<pre class="alt"><span class="lnum">   5:  </span>    DWORD dwPID;</pre>
<pre><span class="lnum">   6:  </span>    CString cStrText;</pre>
<pre class="alt"><span class="lnum">   7:  </span>    CString cStrState;</pre>
<pre><span class="lnum">   8:  </span>    </pre>
<pre class="alt"><span class="lnum">   9:  </span>    DWORD dwOutput;</pre>
<pre><span class="lnum">  10:  </span>    BOOL bRet;</pre>
<pre class="alt"><span class="lnum">  11:  </span>    CHAR inBuffer[10];</pre>
<pre><span class="lnum">  12:  </span>    CHAR outBuffer[10];</pre>
<pre class="alt"><span class="lnum">  13:  </span>    memset(inBuffer, 0, 10);</pre>
<pre><span class="lnum">  14:  </span>    memset(outBuffer, 0, 10);</pre>
<pre class="alt"><span class="lnum">  15:  </span>&nbsp;</pre>
<pre><span class="lnum">  16:  </span>    dwPID = <span class="kwrd">this</span>-&gt;GetDlgItemInt(IDC_STATIC_SELECTED_PID);</pre>
<pre class="alt"><span class="lnum">  17:  </span>    <span class="kwrd">this</span>-&gt;GetDlgItemText(ID_BTN_HIDEORUNHIDE, cStrText);</pre>
<pre><span class="lnum">  18:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  19:  </span>    ultoa(dwPID, inBuffer, 10);</pre>
<pre><span class="lnum">  20:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  21:  </span>    nIndex = QueryItemIndexByPID(dwPID);</pre>
<pre><span class="lnum">  22:  </span>    cStrState = <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.GetItemText(nIndex, 4);</pre>
<pre class="alt"><span class="lnum">  23:  </span>&nbsp;</pre>
<pre><span class="lnum">  24:  </span>    <span class="kwrd">if</span>(cStrText.CompareNoCase(_TEXT(<span class="str">&quot;Hide&quot;</span>)) == 0)</pre>
<pre class="alt"><span class="lnum">  25:  </span>    {</pre>
<pre><span class="lnum">  26:  </span>        <span class="rem">//隐藏 dwPID</span></pre>
<pre class="alt"><span class="lnum">  27:  </span>        bRet = DeviceIoControl(<span class="kwrd">this</span>-&gt;m_hDevice, IO_INSERT_HIDE_PROCESS, inBuffer, 10, </pre>
<pre><span class="lnum">  28:  </span>             &amp;outBuffer, 10, &amp;dwOutput, NULL);</pre>
<pre class="alt"><span class="lnum">  29:  </span>        <span class="kwrd">if</span>(bRet)</pre>
<pre><span class="lnum">  30:  </span>        {</pre>
<pre class="alt"><span class="lnum">  31:  </span>            <span class="kwrd">this</span>-&gt;SetDlgItemText(ID_BTN_HIDEORUNHIDE, _TEXT(<span class="str">&quot;UnHide&quot;</span>));</pre>
<pre><span class="lnum">  32:  </span>            <span class="kwrd">if</span>(cStrState.CompareNoCase(_TEXT(<span class="str">&quot;Protect&quot;</span>)) == 0)</pre>
<pre class="alt"><span class="lnum">  33:  </span>            {</pre>
<pre><span class="lnum">  34:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;HideAndProtect&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  35:  </span>            }</pre>
<pre><span class="lnum">  36:  </span>            <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum">  37:  </span>            {</pre>
<pre><span class="lnum">  38:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;Hide&quot;</span>));</pre>
<pre class="alt"><span class="lnum">  39:  </span>            }</pre>
<pre><span class="lnum">  40:  </span>            MessageBox(_TEXT(<span class="str">&quot; Hide Process Sucess !  &quot;</span>), _TEXT(<span class="str">&quot;Information&quot;</span>), MB_OK | </pre>
<pre class="alt"><span class="lnum">  41:  </span>                     MB_ICONINFORMATION);</pre>
<pre><span class="lnum">  42:  </span>        }</pre>
<pre class="alt"><span class="lnum">  43:  </span>        <span class="kwrd">else</span></pre>
<pre><span class="lnum">  44:  </span>        {</pre>
<pre class="alt"><span class="lnum">  45:  </span>            MessageBox(_TEXT(<span class="str">&quot; Hide Process Failed !  &quot;</span>), _TEXT(<span class="str">&quot;Warning&quot;</span>), MB_OK | MB_ICONERROR);</pre>
<pre><span class="lnum">  46:  </span>        }</pre>
<pre class="alt"><span class="lnum">  47:  </span>    }</pre>
<pre><span class="lnum">  48:  </span>    <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum">  49:  </span>    {</pre>
<pre><span class="lnum">  50:  </span>        <span class="rem">//解除 dwPID 隐藏</span></pre>
<pre class="alt"><span class="lnum">  51:  </span>        bRet = DeviceIoControl(<span class="kwrd">this</span>-&gt;m_hDevice, IO_REMOVE_HIDE_PROCESS, inBuffer, 10, </pre>
<pre><span class="lnum">  52:  </span>             &amp;outBuffer, 10, &amp;dwOutput, NULL);</pre>
<pre class="alt"><span class="lnum">  53:  </span>        <span class="kwrd">if</span>(bRet)</pre>
<pre><span class="lnum">  54:  </span>        {</pre>
<pre class="alt"><span class="lnum">  55:  </span>            <span class="kwrd">this</span>-&gt;SetDlgItemText(ID_BTN_HIDEORUNHIDE, _TEXT(<span class="str">&quot;Hide&quot;</span>));</pre>
<pre><span class="lnum">  56:  </span>            <span class="kwrd">if</span>(cStrState.CompareNoCase(_TEXT(<span class="str">&quot;Protect&quot;</span>)) == 0 || </pre>
<pre class="alt"><span class="lnum">  57:  </span>               cStrState.CompareNoCase(_TEXT(<span class="str">&quot;HideAndProtect&quot;</span>))== 0)</pre>
<pre><span class="lnum">  58:  </span>            {</pre>
<pre class="alt"><span class="lnum">  59:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;Protect&quot;</span>));</pre>
<pre><span class="lnum">  60:  </span>            }</pre>
<pre class="alt"><span class="lnum">  61:  </span>            <span class="kwrd">else</span></pre>
<pre><span class="lnum">  62:  </span>            {</pre>
<pre class="alt"><span class="lnum">  63:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;General&quot;</span>));</pre>
<pre><span class="lnum">  64:  </span>            }</pre>
<pre class="alt"><span class="lnum">  65:  </span>            MessageBox(_TEXT(<span class="str">&quot; UnHide Process Sucess !  &quot;</span>), _TEXT(<span class="str">&quot;Information&quot;</span>), MB_OK | </pre>
<pre><span class="lnum">  66:  </span>                  MB_ICONINFORMATION);</pre>
<pre class="alt"><span class="lnum">  67:  </span>        }</pre>
<pre><span class="lnum">  68:  </span>        <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum">  69:  </span>        {</pre>
<pre><span class="lnum">  70:  </span>            MessageBox(_TEXT(<span class="str">&quot; UnHide Process Failed !  &quot;</span>), _TEXT(<span class="str">&quot;Warning&quot;</span>), MB_OK | MB_ICONERROR);</pre>
<pre class="alt"><span class="lnum">  71:  </span>        }</pre>
<pre><span class="lnum">  72:  </span>    }</pre>
<pre class="alt"><span class="lnum">  73:  </span>}</pre>
<pre><span class="lnum">  74:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  75:  </span>&nbsp;</pre>
<pre><span class="lnum">  76:  </span><span class="rem">//保护进程或者取消对进程的保护操作</span></pre>
<pre class="alt"><span class="lnum">  77:  </span><span class="kwrd">void</span> CSSDTProcessDlg::OnBnClickedBtnProtectorunprotect()</pre>
<pre><span class="lnum">  78:  </span>{</pre>
<pre class="alt"><span class="lnum">  79:  </span>    <span class="kwrd">int</span> nIndex;</pre>
<pre><span class="lnum">  80:  </span>    DWORD dwPID;</pre>
<pre class="alt"><span class="lnum">  81:  </span>    CString cStrText;</pre>
<pre><span class="lnum">  82:  </span>    CString cStrState;</pre>
<pre class="alt"><span class="lnum">  83:  </span>&nbsp;</pre>
<pre><span class="lnum">  84:  </span>    DWORD dwOutput;</pre>
<pre class="alt"><span class="lnum">  85:  </span>    BOOL bRet;</pre>
<pre><span class="lnum">  86:  </span>    CHAR inBuffer[10];</pre>
<pre class="alt"><span class="lnum">  87:  </span>    CHAR outBuffer[10];</pre>
<pre><span class="lnum">  88:  </span>    memset(inBuffer, 0, 10);</pre>
<pre class="alt"><span class="lnum">  89:  </span>    memset(outBuffer, 0, 10);</pre>
<pre><span class="lnum">  90:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  91:  </span>    dwPID = <span class="kwrd">this</span>-&gt;GetDlgItemInt(IDC_STATIC_SELECTED_PID);</pre>
<pre><span class="lnum">  92:  </span>    <span class="kwrd">this</span>-&gt;GetDlgItemText(ID_BTN_PROTECTORUNPROTECT, cStrText);</pre>
<pre class="alt"><span class="lnum">  93:  </span>&nbsp;</pre>
<pre><span class="lnum">  94:  </span>    ultoa(dwPID, inBuffer, 10);</pre>
<pre class="alt"><span class="lnum">  95:  </span>&nbsp;</pre>
<pre><span class="lnum">  96:  </span>    nIndex = QueryItemIndexByPID(dwPID);</pre>
<pre class="alt"><span class="lnum">  97:  </span>    cStrState = <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.GetItemText(nIndex, 4);</pre>
<pre><span class="lnum">  98:  </span>&nbsp;</pre>
<pre class="alt"><span class="lnum">  99:  </span>    <span class="kwrd">if</span>(cStrText.CompareNoCase(_TEXT(<span class="str">&quot;Protect&quot;</span>)) == 0)</pre>
<pre><span class="lnum"> 100:  </span>    {</pre>
<pre class="alt"><span class="lnum"> 101:  </span>        <span class="rem">//保护 dwPID 保护</span></pre>
<pre><span class="lnum"> 102:  </span>        bRet = DeviceIoControl(<span class="kwrd">this</span>-&gt;m_hDevice, IO_INSERT_PROTECT_PROCESS, inBuffer, 10, </pre>
<pre class="alt"><span class="lnum"> 103:  </span>             &amp;outBuffer, 10, &amp;dwOutput, NULL);</pre>
<pre><span class="lnum"> 104:  </span>        <span class="kwrd">if</span>(bRet)</pre>
<pre class="alt"><span class="lnum"> 105:  </span>        {</pre>
<pre><span class="lnum"> 106:  </span>            <span class="kwrd">this</span>-&gt;SetDlgItemText(ID_BTN_PROTECTORUNPROTECT, _TEXT(<span class="str">&quot;UnProtect&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 107:  </span>            <span class="kwrd">if</span>(cStrState.CompareNoCase(_TEXT(<span class="str">&quot;Hide&quot;</span>))== 0)</pre>
<pre><span class="lnum"> 108:  </span>            {</pre>
<pre class="alt"><span class="lnum"> 109:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;HideAndProtect&quot;</span>));</pre>
<pre><span class="lnum"> 110:  </span>            }</pre>
<pre class="alt"><span class="lnum"> 111:  </span>            <span class="kwrd">else</span></pre>
<pre><span class="lnum"> 112:  </span>            {</pre>
<pre class="alt"><span class="lnum"> 113:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;Protect&quot;</span>));</pre>
<pre><span class="lnum"> 114:  </span>            }</pre>
<pre class="alt"><span class="lnum"> 115:  </span>            MessageBox(_TEXT(<span class="str">&quot; Protect Process Sucess !  &quot;</span>), _TEXT(<span class="str">&quot;Information&quot;</span>), MB_OK | </pre>
<pre><span class="lnum"> 116:  </span>                  MB_ICONINFORMATION);</pre>
<pre class="alt"><span class="lnum"> 117:  </span>        }</pre>
<pre><span class="lnum"> 118:  </span>        <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum"> 119:  </span>        {</pre>
<pre><span class="lnum"> 120:  </span>            MessageBox(_TEXT(<span class="str">&quot; Protect Process Failed !  &quot;</span>), _TEXT(<span class="str">&quot;Warning&quot;</span>), MB_OK | MB_ICONERROR);</pre>
<pre class="alt"><span class="lnum"> 121:  </span>        }</pre>
<pre><span class="lnum"> 122:  </span>    }</pre>
<pre class="alt"><span class="lnum"> 123:  </span>    <span class="kwrd">else</span></pre>
<pre><span class="lnum"> 124:  </span>    {</pre>
<pre class="alt"><span class="lnum"> 125:  </span>        <span class="rem">//解除 dwPID 保护</span></pre>
<pre><span class="lnum"> 126:  </span>        bRet = DeviceIoControl(<span class="kwrd">this</span>-&gt;m_hDevice, IO_REMOVE_PROTECT_PROCESS, inBuffer, 10, </pre>
<pre class="alt"><span class="lnum"> 127:  </span>             &amp;outBuffer, 10, &amp;dwOutput, NULL);</pre>
<pre><span class="lnum"> 128:  </span>        <span class="kwrd">if</span>(bRet)</pre>
<pre class="alt"><span class="lnum"> 129:  </span>        {</pre>
<pre><span class="lnum"> 130:  </span>            <span class="kwrd">this</span>-&gt;SetDlgItemText(ID_BTN_PROTECTORUNPROTECT, _TEXT(<span class="str">&quot;Protect&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 131:  </span>            <span class="kwrd">if</span>(cStrState.CompareNoCase(_TEXT(<span class="str">&quot;Hide&quot;</span>)) == 0 || </pre>
<pre><span class="lnum"> 132:  </span>                 cStrState.CompareNoCase(_TEXT(<span class="str">&quot;HideAndProtect&quot;</span>)) == 0)</pre>
<pre class="alt"><span class="lnum"> 133:  </span>            {</pre>
<pre><span class="lnum"> 134:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;Hide&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 135:  </span>            }</pre>
<pre><span class="lnum"> 136:  </span>            <span class="kwrd">else</span></pre>
<pre class="alt"><span class="lnum"> 137:  </span>            {</pre>
<pre><span class="lnum"> 138:  </span>                <span class="kwrd">this</span>-&gt;m_ListCtrlProcess.SetItemText(nIndex, 4, _TEXT(<span class="str">&quot;General&quot;</span>));</pre>
<pre class="alt"><span class="lnum"> 139:  </span>            }</pre>
<pre><span class="lnum"> 140:  </span>            MessageBox(_TEXT(<span class="str">&quot; UnProtect Process Sucess !  &quot;</span>), _TEXT(<span class="str">&quot;Information&quot;</span>), MB_OK | </pre>
<pre class="alt"><span class="lnum"> 141:  </span>                  MB_ICONINFORMATION);</pre>
<pre><span class="lnum"> 142:  </span>        }</pre>
<pre class="alt"><span class="lnum"> 143:  </span>        <span class="kwrd">else</span></pre>
<pre><span class="lnum"> 144:  </span>        {</pre>
<pre class="alt"><span class="lnum"> 145:  </span>            MessageBox(_TEXT(<span class="str">&quot; UnProtect Process Failed !  &quot;</span>), _TEXT(<span class="str">&quot;Warning&quot;</span>), MB_OK | MB_ICONERROR);</pre>
<pre><span class="lnum"> 146:  </span>        }</pre>
<pre class="alt"><span class="lnum"> 147:  </span>    }</pre>
<pre><span class="lnum"> 148:  </span>}</pre>
<pre>          </pre>
<pre>&nbsp;</pre>
</div>
<p><span style="font-family:微软雅黑; font-size:24px; color:#ff0000"><strong>5. 小结：</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:12px">介绍这个应用程序呢，还真是不好写，因为感觉整个 Demo 里面却是没有什么好介绍的，</span></p>
<p><span style="font-family:Courier New; font-size:12px">无非就是获取到所有的进程，然后通过一个 ListCtrl 来显示这些数据，</span></p>
<p><span style="font-family:Courier New; font-size:12px">然后用户选择一个进程，单击一下隐藏呢，我就在这个按钮的消息处理函数中和内核程序通过 DeviceIoControl 通信一下，</span></p>
<p><span style="font-family:Courier New; font-size:12px">将这个进程的 PID 传递给内核程序，其他的就都不需要理会了 ~
</span><span style="font-family:Courier New; font-size:12px">所以转来转去的，也没什么好些的，干脆就写到这里得了，</span></p>
<p><span style="font-family:Courier New; font-size:12px">等下将整个 Demo 打个包，直接提供下载，</span><span style="font-family:Courier New; font-size:12px"><span style="font-family:Verdana">我这里说得口干舌燥也没什么用，</span>感兴趣的自己下载了源码去慢慢玩得了 ~
</span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>最后再总结一个 SSDT Hook 的优点，那就是 SSDT Hook 无论你是 Windows XP 还是 Server 或者 Vista 或者 Win7，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>你都是可以很好的运行程序的，所以你下载的 Demo 你可以放心的在上面的这些操作系统上运行，当然 64 位的除外，</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong>64 位的操作系统虽然我没有做过测试，但是我估摸着会蓝屏的 ~ 有兴趣的可以去蓝一次 ~
</strong></span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong><u>下载 Demo</u></strong></span><a target="_blank" href="http://files.cnblogs.com/BoyXiao/HookDemo.zip"><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong>
 Source Code</strong></span></a><span style="font-family:Courier New; font-size:14px; color:#ff0000"><strong><u>
</u></strong></span></p>
<p><span style="font-family:Courier New; font-size:12px"></span></p>
<p><span style="font-family:Courier New; font-size:12px"></span></p>
<p><span style="font-family:Courier New; font-size:12px"><span style="font-family:Verdana">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p><span style="font-family:Courier New; font-size:12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-family:微软雅黑"><strong>版权所有，<strong>欢</strong>迎转载，但转载请注明： 转载自&nbsp;
<a target="_blank" href="http://www.cnblogs.com/BoyXiao/"><strong>Zachary.XiaoZhen - 梦想的天空</strong></a></strong></span></p>
</div>
</div>
<br>
<p></p>
</div>
</div>
<br>
<p></p>
<p><span style="font-family:Courier New; font-size:12px; color:#0000ff"><strong><br>
</strong></span></p>
</div>
</div>
   
</div>




<!-- Baidu Button BEGIN -->




<div class="bdsharebuttonbox tracking-ad" style="float: right;" data-mod="popu_172">
<a href="#" class="bds_more" data-cmd="more" style="background-position:0 0 !important; background-image: url(http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png) !important"></a>
<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"  style="background-position:0 -52px !important"></a>
<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"style="background-position:0 -104px !important"></a>
<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"style="background-position:0 -260px !important"></a>
<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"style="background-position:0 -208px !important"></a>
<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"style="background-position:0 -1612px !important" ></a>
</div>
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script>
<!-- Baidu Button END -->

   

<!--172.16.140.13-->

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->



 


        <div id="digg" ArticleId="47276173" >
            <dl id="btnDigg" class="digg digg_disable"  onclick="btndigga();">
               
                 <dt>顶</dt>
                <dd>0</dd>
            </dl>
           
              
            <dl id="btnBury" class="digg digg_disable"  onclick="btnburya();">
              
                  <dt>踩</dt>
                <dd>0</dd>               
            </dl>
            
        </div>
     <div class="tracking-ad" data-mod="popu_222"><a href="javascript:void(0);" >&nbsp;</a>   </div>
    <div class="tracking-ad" data-mod="popu_223"> <a href="javascript:void(0);" >&nbsp;</a></div>
    <script type="text/javascript">
        function btndigga() {
            $(".tracking-ad[data-mod='popu_222'] a").click();
        }
        function btnburya() {
            $(".tracking-ad[data-mod='popu_223'] a").click();
        }
            </script>

   <ul class="article_next_prev">
                <li class="prev_article"><span  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='http://blog.csdn.net/flyingleo1981/article/details/47276037';">上一篇</span><a href="http://blog.csdn.net/flyingleo1981/article/details/47276037" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])">【转】中国顶级黑客</a></li>
                <li class="next_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='http://blog.csdn.net/flyingleo1981/article/details/47276473';">下一篇</span><a href="http://blog.csdn.net/flyingleo1981/article/details/47276473" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])">Windows系统编程之异步I/O和完成端口</a></li>
    </ul>

    <div style="clear:both; height:10px;"></div>


            <div class="similar_article"   >
                    <h4></h4>
                    <div class="similar_c"style="margin:20px 0px 0px 0px">
                        <div class="similar_c_t">
                          &nbsp;&nbsp;相关文章推荐
                        </div>
                   
                        <div class="similar_wrap tracking-ad" data-mod="popu_36"  style="max-height:250px">                       
                            <ul class="similar_list fl">    
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/qq935283478/6754765" title="实现程序在驱动层面的保护;一份用于隐藏进程及其线程的rootkit驱动程序源代码." strategy="BlogCommendFromCsdn_0" target="_blank">实现程序在驱动层面的保护;一份用于隐藏进程及其线程的rootkit驱动程序源代码.</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/huiyiCourse/series_detail/60?utm_source=blog7" title="【直播】打通Linux脉络 进程、线程和调度--宋宝华" strategy="undefined" target="_blank">【直播】打通Linux脉络 进程、线程和调度--宋宝华</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://blog.csdn.net/php_fly/article/details/9202379" title="SSDT Hook实现内核级的进程保护" strategy="BlogCommendFromCsdn_1" target="_blank">SSDT Hook实现内核级的进程保护</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/huiyiCourse/series_detail/62?utm_source=blog7" title="【直播】系统集成工程师必过冲刺--任铄" strategy="undefined" target="_blank">【直播】系统集成工程师必过冲刺--任铄</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/yanruichong/9507671" title="超级内核工具【标准版】" strategy="BlogCommendFromCsdn_2" target="_blank">超级内核工具【标准版】</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/huiyiCourse/series_detail/61?utm_source=blog7" title="【直播】机器学习30天系统掌握--唐宇迪" strategy="undefined" target="_blank">【直播】机器学习30天系统掌握--唐宇迪</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://blog.csdn.net/SR0ad/article/details/8126490" title="基于SSDT HOOK技术的Ring0级进程保护组件设计与实现" strategy="BlogCommendFromCsdn_3" target="_blank">基于SSDT HOOK技术的Ring0级进程保护组件设计与实现</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/course/detail/458?utm_source=blog7" title="【课程】Oracle从入门到精通--文心" strategy="undefined" target="_blank">【课程】Oracle从入门到精通--文心</a>
                                   </li>
                            </ul>
                              <ul class="similar_list fr">      
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/muhuohacker/2163450" title="HOOK技术的Ring0级进程保护组件设计与实现" strategy="BlogCommendFromCsdn_4" target="_blank">HOOK技术的Ring0级进程保护组件设计与实现</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/course/detail/545?utm_source=blog7" title="【套餐】Android入门实战教程--巫文杰" strategy="undefined" target="_blank">【套餐】Android入门实战教程--巫文杰</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://blog.csdn.net/junjie1595/article/details/8158240" title="进程隐藏与进程保护（SSDT Hook 实现）（二）" strategy="BlogCommendFromCsdn_5" target="_blank">进程隐藏与进程保护（SSDT Hook 实现）（二）</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://edu.csdn.net/course/detail/474?utm_source=blog7" title="【课程】 C++语言基础 --贺利坚" strategy="undefined" target="_blank">【课程】 C++语言基础 --贺利坚</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/2shcm/1466027" title="XueTr0.27 (比冰刃IceSword还强的软件)" strategy="BlogCommendFromCsdn_6" target="_blank">XueTr0.27 (比冰刃IceSword还强的软件)</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/gongxi7facai/4487259" title="[《黑客防线》2009黑客编程VC专辑]源码part1" strategy="BlogCommendFromCsdn_7" target="_blank">[《黑客防线》2009黑客编程VC专辑]源码part1</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://download.csdn.net/download/johnllon/8474783" title="黑客防线2011精华奉献本.下册" strategy="BlogCommendFromCsdn_8" target="_blank">黑客防线2011精华奉献本.下册</a>
                                   </li>
                                   <li>
                                       <em>•</em>
                                       <a href="http://blog.csdn.net/cosmoslx/article/details/5734951" title="SSDT HOOK实现进程保护" strategy="BlogCommendFromCsdn_9" target="_blank">SSDT HOOK实现进程保护</a>
                                   </li>
                            </ul>
                        </div>
                    </div>
                </div>   
      
</div>

    <div>
        

        <script type="text/javascript">
            /*博客内容页下方Banner1-728*90，创建于2016-12-13*/
            var cpro_id = "u2843949";
        </script>
        <script type="text/javascript" src="http://cpro.baidustatic.com/cpro/ui/c.js"></script>

     </div>

<div id="suggest"></div>
         <script  language="javascript" type='text/javascript'>     
             $(function(){
                 $.get("/flyingleo1981/svc/GetSuggestContent/47276173",function(data){
                     $("#suggest").html(data);
                 });     
             });             
         </script>  



            
                                    
            
                                    

        <!-- 广告位开始 -->
        <!-- 广告位结束 -->


<div class="comment_class">
    <div id="comment_title" class="panel_head">
        <span class="see_comment">查看评论</span><a name="comments"></a></div>
    <div id="comment_list">
    </div>
    <div id="comment_bar">
    </div>
    <div id="comment_form">
    </div>
    <div class="announce">
        * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
</div>

<script type="text/javascript">
    var fileName = '47276173';
    var commentscount = 1;
    var islock = false
</script>

    <div id="ad_bot">
    </div>
<div id="report_dialog">
</div>

<div id="d-top"  style="bottom:60px;">

        <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="http://static.blog.csdn.net/images/blog-icon-reply.png" alt="快速回复">
        </a>    
    <a id="d-top-a" class="btn btn-top backtop"  style="display: none;" title="返回顶部" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])" style="">         
         <img src="http://static.blog.csdn.net/images/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);    
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>





<div id="pop_win" style="display:none ;position: absolute; z-index: 10000; border: 1px solid rgb(220, 220, 220); top: 222.5px; left: 630px; opacity: 1; background: none 0px 0px repeat scroll rgb(255, 255, 255);">
    
</div>
<div id="popup_mask"></div>
<style>
    #popup_mask
    {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        left: 0px;
        top: 0px;
        opacity: 0.3;
        filter: alpha(opacity=30);
        display: none;
    }

</style>




<script type="text/javascript">
    $(function(){        
        
        setTimeout(function(){
            $(".comment_body:contains('回复')").each(function(index,item){
                var u=$(this).text().split('：')[0].toString().replace("回复","")
                var thisComment=$(this);
                if(u)
                {
                    $.getJSON("https://passport.csdn.net/get/nick?callback=?", {users: u}, function(a) {
                        if(a!=null&&a.data!=null&&a.data.length>0)
                        {
                            nick=a.data[0].n; 
                            if(u!=nick)
                            {
                                thisComment.text(thisComment.text().replace(u,nick));  
                            }
                        }       
                    });  
                }
            });         

        },200);  

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },5000);

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },10000);

        setTimeout(function(){
            $(".math").each(function(index,value){$(this).find("span").last().css("color","#fff"); })
        },15000);
        
        setTimeout(function(){
            $("a img[src='http://js.tongji.linezing.com/stats.gif']").parent().css({"position":"absolute","left":"50%"});
        },300);
    });

    function loginbox(){
        var $logpop=$("#pop_win");
        $logpop.html('<iframe src="https://passport.csdn.net/account/loginbox?service=http://static.blog.csdn.net/callback.htm" frameborder="0" height="600" width="400" scrolling="no"></iframe>');

        $('#popup_mask').css({
            opacity: 0.5,
            width: $( document ).width() + 'px',
            height:  $( document ).height() + 'px'
        });
        $('#popup_mask').css("display","block");
 
        $logpop.css( {
            top: ($( window ).height() - $logpop.height())/ 2  + $( window 
       ).scrollTop() + 'px',
            left:($( window ).width() - $logpop.width())/ 2
        } );
 
        setTimeout( function () {
            $logpop.show();
            $logpop.css( {
                opacity: 1
            } );
        }, 200 );
 
        $('#popup_mask').unbind("click");
        $('#popup_mask').bind("click", function(){
            $('#popup_mask').hide();
            var $clopop = $("#pop_win");
            $("#common_ask_div_sc").css("display","none");
            $clopop.css( {
                opacity: 0
            } );
            setTimeout( function () {
                $clopop.hide();
            }, 350 );
            return false;
        });
    }   

    var articletitle='进程隐藏与进程保护（SSDT Hook 实现)';

</script>










                        <div class="clear">
                        </div>
                    </div>                   
                
            </div>
                   
           <div id="side">
               
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/flyingleo1981" target="_blank">
    <img src="http://avatar.csdn.net/D/2/A/1_flyingleo1981.jpg" title="访问我的空间" style="max-width:90%"/>
    </a>
    <br />
    <span><a href="http://my.csdn.net/flyingleo1981" class="user_name" target="_blank">flyingleo1981</a></span>
</div>
<div class="interact">

    <a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]"></a>

 <a href="javascript:void(0);" class="letter"  title="[发私信]" onclick="window.open('http://msg.csdn.net/letters/model?receiver=flyingleo1981','_blank','height=350,width=700');_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_sixin'])"></a>  
</div>
<div id="blog_medal">
                <div id="bms_box">
                                            <a  target="_blank">
                                                    <img src="http://c.csdnimg.cn/jifen/images/xunzhang/xunzhang/chizhiyiheng.png" onmouseover="m_over_m(this,4)" onmouseout="m_out_m()" alt="1" >
                                            </a>
               </div>
</div>
<ul id="blog_rank">
    <li>访问：<span>454238次</span></li>
    <li>积分：<span>6438</span> </li>    
    <li >等级： <span style="position:relative;display:inline-block;z-index:1" >
            <img src="http://c.csdnimg.cn/jifen/images/xunzhang/jianzhang/blog6.png" alt="" style="vertical-align: middle;" id="leveImg">
            <div id="smallTittle" style=" position: absolute;  left: -24px;  top: 25px;  text-align: center;  width: 101px;  height: 32px;  background-color: #fff;  line-height: 32px;  border: 2px #DDDDDD solid;  box-shadow: 0px 2px 2px rgba (0,0,0,0.1);  display: none;   z-index: 999;">
            <div style="left: 42%;  top: -8px;  position: absolute;  width: 0;  height: 0;  border-left: 10px solid transparent;  border-right: 10px solid transparent;  border-bottom: 8px solid #EAEAEA;"></div>
            积分：6438 </div>
        </span>  </li>
    <li>排名：<span>第3818名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>104篇</span></li>
    <li>转载：<span>514篇</span></li>
    <li>译文：<span>1篇</span></li>
    <li>评论：<span>19条</span></li>
</ul>
</ul>
</div>


<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body" class="form_search">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search csdn-tracking-statistics" target="_blank"  data-mod="popu_306">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="button" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div>

<script type="text/javascript">

   
    $(function () {
        $("#btnSubmit").unbind("click");
        $("#btnSubmit").click(function () {           
            search();
        });

        $("#frmSearch").submit(function () {           
            search();
            return false;
        });

        function search()
        {
            if ($("#inputSearch").val() == "") {               
                alert("请录入搜索关键词！");                         
                return false;
            }
            //var url = "http://so.csdn.net/so/search/s.do?q=" + encodeURIComponent($("#inputSearch").val()) + "&u=" + username + "&t=blog";           
            var url = "https://www.baidu.com/s?wd=" + encodeURIComponent($("#inputSearch").val()) + "%20site%3Ablog.csdn.net"
            window.location.href = url;
        }   
    });
</script><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list">
<!--归档统计-->
<li><a href="/flyingleo1981/article/month/2017/08">2017年08月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2017/07">2017年07月</a><span>(5)</span></li><li><a href="/flyingleo1981/article/month/2017/06">2017年06月</a><span>(3)</span></li><li><a href="/flyingleo1981/article/month/2017/05">2017年05月</a><span>(15)</span></li><li><a href="/flyingleo1981/article/month/2017/04">2017年04月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2017/03">2017年03月</a><span>(5)</span></li><li><a href="/flyingleo1981/article/month/2017/02">2017年02月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2017/01">2017年01月</a><span>(4)</span></li><li><a href="/flyingleo1981/article/month/2016/12">2016年12月</a><span>(38)</span></li><li><a href="/flyingleo1981/article/month/2016/11">2016年11月</a><span>(2)</span></li><li><a href="/flyingleo1981/article/month/2016/10">2016年10月</a><span>(9)</span></li><li><a href="/flyingleo1981/article/month/2016/09">2016年09月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2016/08">2016年08月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2016/07">2016年07月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2016/06">2016年06月</a><span>(2)</span></li><li><a href="/flyingleo1981/article/month/2016/05">2016年05月</a><span>(7)</span></li><li><a href="/flyingleo1981/article/month/2016/04">2016年04月</a><span>(4)</span></li><li><a href="/flyingleo1981/article/month/2016/03">2016年03月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2016/02">2016年02月</a><span>(5)</span></li><li><a href="/flyingleo1981/article/month/2016/01">2016年01月</a><span>(3)</span></li><li><a href="/flyingleo1981/article/month/2015/12">2015年12月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2015/11">2015年11月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2015/10">2015年10月</a><span>(4)</span></li><li><a href="/flyingleo1981/article/month/2015/09">2015年09月</a><span>(2)</span></li><li><a href="/flyingleo1981/article/month/2015/08">2015年08月</a><span>(8)</span></li><li><a href="/flyingleo1981/article/month/2015/07">2015年07月</a><span>(7)</span></li><li><a href="/flyingleo1981/article/month/2015/05">2015年05月</a><span>(5)</span></li><li><a href="/flyingleo1981/article/month/2015/04">2015年04月</a><span>(7)</span></li><li><a href="/flyingleo1981/article/month/2015/03">2015年03月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2015/02">2015年02月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2015/01">2015年01月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2014/12">2014年12月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2014/11">2014年11月</a><span>(2)</span></li><li><a href="/flyingleo1981/article/month/2014/10">2014年10月</a><span>(3)</span></li><li><a href="/flyingleo1981/article/month/2014/09">2014年09月</a><span>(11)</span></li><li><a href="/flyingleo1981/article/month/2014/08">2014年08月</a><span>(3)</span></li><li><a href="/flyingleo1981/article/month/2014/07">2014年07月</a><span>(18)</span></li><li><a href="/flyingleo1981/article/month/2014/06">2014年06月</a><span>(19)</span></li><li><a href="/flyingleo1981/article/month/2014/05">2014年05月</a><span>(21)</span></li><li><a href="/flyingleo1981/article/month/2014/04">2014年04月</a><span>(1)</span></li><li><a href="/flyingleo1981/article/month/2014/03">2014年03月</a><span>(5)</span></li><li><a href="/flyingleo1981/article/month/2014/02">2014年02月</a><span>(14)</span></li><li><a href="/flyingleo1981/article/month/2014/01">2014年01月</a><span>(11)</span></li><li><a href="/flyingleo1981/article/month/2013/12">2013年12月</a><span>(22)</span></li><li><a href="/flyingleo1981/article/month/2013/11">2013年11月</a><span>(54)</span></li><li><a href="/flyingleo1981/article/month/2013/10">2013年10月</a><span>(3)</span></li><li><a href="/flyingleo1981/article/month/2013/09">2013年09月</a><span>(11)</span></li><li><a href="/flyingleo1981/article/month/2013/08">2013年08月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2013/07">2013年07月</a><span>(23)</span></li><li><a href="/flyingleo1981/article/month/2013/06">2013年06月</a><span>(12)</span></li><li><a href="/flyingleo1981/article/month/2013/05">2013年05月</a><span>(12)</span></li><li><a href="/flyingleo1981/article/month/2013/04">2013年04月</a><span>(28)</span></li><li><a href="/flyingleo1981/article/month/2013/03">2013年03月</a><span>(22)</span></li><li><a href="/flyingleo1981/article/month/2013/02">2013年02月</a><span>(2)</span></li><li><a href="/flyingleo1981/article/month/2013/01">2013年01月</a><span>(17)</span></li><li><a href="/flyingleo1981/article/month/2012/12">2012年12月</a><span>(19)</span></li><li><a href="/flyingleo1981/article/month/2012/11">2012年11月</a><span>(24)</span></li><li><a href="/flyingleo1981/article/month/2012/10">2012年10月</a><span>(6)</span></li><li><a href="/flyingleo1981/article/month/2012/09">2012年09月</a><span>(17)</span></li><li><a href="/flyingleo1981/article/month/2012/08">2012年08月</a><span>(16)</span></li><li><a href="/flyingleo1981/article/month/2012/07">2012年07月</a><span>(32)</span></li><li><a href="/flyingleo1981/article/month/2012/06">2012年06月</a><span>(17)</span></li>
</div>
</ul>
</div>
<div id="hotarticls" class="panel tracking-ad" data-mod="popu_340">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="/flyingleo1981/article/details/7681734" title="如何使用CMAKE生成makefile文件">如何使用CMAKE生成makefile文件</a><span>(6893)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/53008931" title="三次样条插值(Cubic Spline Interpolation)及代码实现(C语言)">三次样条插值(Cubic Spline Interpolation)及代码实现(C语言)</a><span>(5648)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/7739490" title="ps -aux出来的stat结果Ss,Sl,SN~~">ps -aux出来的stat结果Ss,Sl,SN~~</a><span>(4568)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/8669417" title="Linux_多核系统下绑定进程或线程到指定CPU_核执行和调优">Linux_多核系统下绑定进程或线程到指定CPU_核执行和调优</a><span>(4559)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/7793665" title="STL源码剖析---红黑树原理详解">STL源码剖析---红黑树原理详解</a><span>(4168)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/7790161" title="完全反截屏">完全反截屏</a><span>(3815)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/7665873" title="拆掉思维里的墙：亲身经历后才能明白？">拆掉思维里的墙：亲身经历后才能明白？</a><span>(3792)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/7895988" title="c++ 获取进程内存使用情况">c++ 获取进程内存使用情况</a><span>(3397)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/8818908" title="WAMP5下修改80端口/修改localhost和mysqladmin的默认URL链接/修改phpmyadmin默认密码">WAMP5下修改80端口/修改localhost和mysqladmin的默认URL链接/修改phpmyadmin默认密码</a><span>(3266)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/16121303" title="vxworks下socket编程 TCP 通信">vxworks下socket编程 TCP 通信</a><span>(3126)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel tracking-ad" data-mod="popu_341">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="/flyingleo1981/article/details/24986963" title="OpenCL 学习step by step (6) 旋转图像">OpenCL 学习step by step (6) 旋转图像</a><span>(3)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/24986767" title="OpenCL 学习step by step (2) 一个简单的OpenCL的程序">OpenCL 学习step by step (2) 一个简单的OpenCL的程序</a><span>(2)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/12050023" title="windbg调试HEAP">windbg调试HEAP</a><span>(2)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/52116823" title="让windows7的蜂鸣器响起来【需要自己增加pcie硬件了。。】">让windows7的蜂鸣器响起来【需要自己增加pcie硬件了。。】</a><span>(2)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/8901074" title="boost::asio::ip::tcp实现网络通信">boost::asio::ip::tcp实现网络通信</a><span>(1)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/8650571" title="十大流行PHP开发框架介绍">十大流行PHP开发框架介绍</a><span>(1)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/16898771" title="vxworks 开发环境搭建">vxworks 开发环境搭建</a><span>(1)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/9309695" title="WinPcap编程之HTTP协议还原">WinPcap编程之HTTP协议还原</a><span>(1)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/18654473" title="环形缓冲区类（C++源码）绝对可用">环形缓冲区类（C++源码）绝对可用</a><span>(1)</span>
</li>
<li>
<a href="/flyingleo1981/article/details/8061410" title="Google Protocol Buffers 之.Net应用">Google Protocol Buffers 之.Net应用</a><span>(1)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend">
<ul>
<li><a href="http://blog.csdn.net/blogdevteam/article/details/77651442" target="_blank">* CSDN日报20170828——《4个方法快速打造你的阅读清单》</a></li>
<li><a href="http://blog.csdn.net/blogdevteam/article/details/77647813" 
target="_blank">* CSDN博客模板调查问卷</a></li>
<li><a href="http://blog.csdn.net/yhaolpz/article/details/77366154"target="_blank">* 动手打造史上最简单的 Recycleview 侧滑菜单</a></li>
<li><a href="http://blog.csdn.net/sweettool/article/details/77018506" 
target="_blank">* TCP网络通讯如何解决分包粘包问题</a></li>
<li><a href="http://blog.csdn.net/dc_726/article/details/77728729" 
target="_blank">* 程序员的八重境界</a></li>
<li><a href="http://blog.csdn.net/pangpang123654/article/details/77720036" 
target="_blank">* 四大线程池详解
</a></li>

</ul></ul>
</div>


<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="/flyingleo1981/article/details/8650571#comments">十大流行PHP开发框架介绍</a>
    <p style="margin:0px;"><a href="/zhizhanglaji" class="user_name">zhizhanglaji</a>:
我要是个框架都玩一遍！！！
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/47276173#comments">进程隐藏与进程保护（SSDT Hook 实现)</a>
    <p style="margin:0px;"><a href="/Grace2010e" class="user_name">Grace2010e</a>:
资源现在下载不聊了，小学期在做这个课题，求源代码demo，万分感谢！！！2560340863@qq....
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/24986963#comments">OpenCL 学习step by step (6) 旋转图像</a>
    <p style="margin:0px;"><a href="/wd1603926823" class="user_name">wd1603926823</a>:
我后来将kernel第二个参数 在host上向buffer申请一个256*sizeof(cl_uch...
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/24986963#comments">OpenCL 学习step by step (6) 旋转图像</a>
    <p style="margin:0px;"><a href="/wd1603926823" class="user_name">wd1603926823</a>:
不知道你有自己运行这个程序没  原作者是在windows进行OpenCL开发 我是在linux 所以...
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/18654473#comments">环形缓冲区类（C++源码）绝对可用</a>
    <p style="margin:0px;"><a href="/mingmiracle01" class="user_name">mingmiracle01</a>:
“m_nWritePos = (m_nReadPos &gt;= count - leftcount) ?...
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/52116823#comments">让windows7的蜂鸣器响起来【需要自己增加pcie硬件了。。】</a>
    <p style="margin:0px;"><a href="/flyingleo1981" class="user_name">flyingleo1981</a>:
@monkey07118124:抱歉后来测试过了，还是走的声卡，主板改了。需要把题目改一下了。。。
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/52116823#comments">让windows7的蜂鸣器响起来【需要自己增加pcie硬件了。。】</a>
    <p style="margin:0px;"><a href="/monkey07118124" class="user_name">monkey07118124</a>:
我想问下，您这代码能解决Win7下Beep不响的问题么？为什么我试了下，Win7蜂鸣器不响？好像声音...
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/51122836#comments">学习 FPGA 经验与书籍</a>
    <p style="margin:0px;"><a href="/qwer19931004" class="user_name">qwer19931004</a>:
谢谢
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/51122836#comments">OpenCL 学习step by step (6) 旋转图像</a>
    <p style="margin:0px;"><a href="/lh13102383138" class="user_name">lh13102383138</a>:
您好，老狼先生。我为什么failed to load kernel?
    </p>
    </li>
    <li>
   
         <a href="/flyingleo1981/article/details/24986767#comments">OpenCL 学习step by step (2) 一个简单的OpenCL的程序</a>
    <p style="margin:0px;"><a href="/lh13102383138" class="user_name">lh13102383138</a>:
我是新手，希望您能详细简单一点说明。谢谢您了。
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>

                   <!-- 广告位开始 -->                    <!-- 广告位结束 -->
                   <div class="tracking-ad" data-view="true"  data-mtp="63" data-order="40" data-con="ad_content_1260" style="width: 200px; height: 500px;">
                         <div id="nav_show_top_stop" style="width: 200px;height: 500px;z-index:1000"><div id="cpro_u2734128"></div>
                             <div id="cpro_u3031287"></div></div>
                   </div>
                <script type="text/javascript">
                    setTimeout(function () {
                        var naviga_offsetTop = 0;
                        function naviga_stay_top() { var scrollTop = jQuery(document).scrollTop(); if (scrollTop > naviga_offsetTop) { jQuery("#nav_show_top_stop").css({ "position": "fixed" }); jQuery("#nav_show_top_stop").css({ "top": "0px" }); } else { jQuery("#nav_show_top_stop").css({ "position": "fixed" }); jQuery("#nav_show_top_stop").css({ "top": naviga_offsetTop - scrollTop + "px" }); } }
                        function onload_function() { naviga_offsetTop = jQuery("#nav_show_top_stop").position().top; jQuery(window).bind("scroll", naviga_stay_top); jQuery(window).bind("mousewheel", naviga_stay_top); jQuery(document).bind("scroll", naviga_stay_top); jQuery(document).bind("mousewheel", naviga_stay_top); } jQuery(document).ready(onload_function);

                    }, 200);
                </script>                    
<script type="text/javascript">(window.cproArray = window.cproArray || []).push({ id: "u2734128" });  </script> 
                    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script> 
                   <script type="text/javascript">
                       /*PC端-博客内容页左侧Button2-200*200-2017/7/10*/
                       (window.cproArray = window.cproArray || []).push({ id: "u3031287" });
</script>
<script type="text/javascript" src="http://cpro.baidustatic.com/cpro/ui/c.js"></script>

           </div>   

            <div class="clear">
            </div>
        </div>

        








    <script type="text/javascript" src="http://passport.csdn.net/content/loginbox/login.js"></script>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<span class='tracking-ad' data-mod='popu_167'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a></span>"
                    + "<span class='tracking-ad' data-mod='popu_170'><a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a></span>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });

        $(".bar").show();
    });
</script>





    </div>
      <!--new top-->
    

     

   
   
     <!--new top-->
   
   

    
    
    
   

   


       <script type="text/javascript" src="http://static.blog.csdn.net/public/res/bower-libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
          <script type="text/javascript">
              //$(function () {
              //    setTimeout(function () {
              //        var searchtitletags = articletitle + ',' + $("#tags").html();
              //        searchService({
              //            index: 'blog',
              //            query: searchtitletags,
              //            from: 5,
              //            size: 5,
              //            appendTo: '#res',
              //            url: 'recommend',
              //            his: 2,
              //            client: "blog_cf_enhance",
              //            tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
              //        });
              //    }, 1000);
              //});

         </script>
    
    <script src="http://static.blog.csdn.net/scripts/csdn_blog_detail.min.js" type="text/javascript"></script>
        
    <script type="text/javascript" src="http://c.csdnimg.cn/blog/csdn_public_blog_detail.min.js?20170719001"></script>

    <script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=768829"></script>

     
    


  <div id="a52b5334d" style="width: 1px; height: 1px; display: none;">
                    <script id="adJs52b5334"></script>
                    <script>document.getElementById("adJs52b5334").src = "http://ads.csdn.net/js/opt/52b5334.js?t=" + Math.random();</script>
   </div>

    
    
        
     

    
          
    <div class="pop_CA_cover"  style="display:none"></div>
    <div class="pop pop_CA"  style="display:none">
          <div class="CA_header">
            收藏助手
            <span class="cancel_icon"  id="fapancle"  onclick="$('.pop_CA').hide();$('.pop_CA_cover').hide();"></span>
          </div>
          <iframe src="" id="fa" frameborder="0" width="100%" height="360"  scrolling="no" ></iframe>
    </div>


        <script type="text/javascript">

            $(function () {
                var fromjs = $("#fromjs");
                if (fromjs.length > 0) {
                    $("#fromjs .markdown_views pre").addClass("prettyprint");
                    prettyPrint();

                    $('pre.prettyprint code').each(function () {
                        var lines = $(this).text().split('\n').length;
                        var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                        $(this).addClass('has-numbering').parent().append($numbering);
                        for (i = 1; i <= lines; i++) {
                            $numbering.append($('<li/>').text(i));
                        };
                        $numbering.fadeIn(1700);
                    });

                    $('.pre-numbering li').css("color", "#999");
                }
            });

            $(".markdown_views a[target!='_blank']").attr("target", "_blank");

            //$(".toc a[target='_blank']").attr("target", "");

            setTimeout(function () {
                $(".toc a[target='_blank']").attr("target", "");
            }, 500);

        </script>

</body>
</html>   
